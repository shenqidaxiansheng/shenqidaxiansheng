<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只神奇的DXS</title>
  
  <subtitle>一名计算机学生的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenqidaxiansheng.github.io/"/>
  <updated>2019-10-08T10:17:08.883Z</updated>
  <id>http://shenqidaxiansheng.github.io/</id>
  
  <author>
    <name>Jing Hua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统导论第七章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操作系统导论第七章/</id>
    <published>2019-10-08T09:43:11.612Z</published>
    <updated>2019-10-08T10:17:08.883Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第七章：进程调度"><a href="#操作系统导论第七章：进程调度" class="headerlink" title="操作系统导论第七章：进程调度"></a>操作系统导论第七章：进程调度</h1><p>操作系统该如何决定切换进程？如何运行进程使得效率最大化？</p><a id="more"></a><h2 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h2><p>1、周转时间<br>$T_{周转时间}=T_{完成时间}-T_{到达时间}$<br>2、响应时间<br>$T_{响应时间}=T_{第一次执行时间}-T_{到达时间}$</p><h2 id="先进先出（FIFO）调度原则"><a href="#先进先出（FIFO）调度原则" class="headerlink" title="先进先出（FIFO）调度原则"></a>先进先出（FIFO）调度原则</h2><p>假设3个工作 a，b，c工作长度为10s，它们大致在相同时间到达（$T_{到达}=0$)但是a比b稍微早一点点，b比c稍微早一点点。<br>那么平均周转时间是$T=(10+20+30)/3 = 20$<br>但是假设a = 100，b和c仍然是10<br>那么平均周转时间是$T=(100+110+120)/3 = 110$<br>可以看出，FIFO调度策略对周转时间不友好</p><h2 id="最短任务优先-（SJF）"><a href="#最短任务优先-（SJF）" class="headerlink" title="最短任务优先 （SJF）"></a>最短任务优先 （SJF）</h2><p>仍然考虑a = 100，b和c仍然是10的情况<br>平均周转时间是$T=(10+20+120)/3 = 50$<br>但是，如果abc不是同时到达，而是a先到达，那么平均周转时间和FIFO一样了。</p><h2 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h2><p>为了解决这个问题，我们让最短完成时间的任务先运行，那么即使是a先到达，但在bc到达时切换到bc进程运行，这样平均周转时间就又恢复成50s。</p><h2 id="轮转（RR）调度策略"><a href="#轮转（RR）调度策略" class="headerlink" title="轮转（RR）调度策略"></a>轮转（RR）调度策略</h2><p>前面都只是针对周转时间，但是响应时间如何（在一个好的交互系统，响应时间尤为重要，用户不会愿意等它前面的进程完成后才响应当前进行的操作）<br>这就引出了一种新的调度算法：轮转<br>RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成。</p><h2 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h2><p>当进程请求I/O时，操作系统可以切换下一个进程，等进程I/O请求完成后，再切换回来，提升CPU使用效率。</p><h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><p>1、</p><p>SJF为最短任务优先原则，现在用这个策略调度长度为200的3个作业，由于作业长度一样（都为200），则假设a、b、b先后运行，那么各个响应周转时间应该如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173735334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>-c测试：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173802907.png"></p><p>与计算相符。</p><p>FIFO为先进先出策略，即先到的任务先运行，由于三个作业长度都为200，所以结果应该与SJF策略相同，-c测试：</p><p>一样。</p><p>2、</p><p>采用SJF策略调度，那么先后运行的任务是 100 200 300</p><p>假设它们为a b c 任务，那么各个时间计算如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173857430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173920851.png"><br>采用FIFO策略，假设任务到达的先后顺序为 100 200 300</p><p>那么需要的各个时间应该与SJF调度是一样的。如果是 300 200 100，那么需要的时间不同：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173932306.png"></p><p>3、</p><p>RR调度程序，即轮转调度，在一个时间片（time<br>slice，有时称为调度量子）内运行一个工作，然后切换到队列的下一个任务，即每个时间片切换一个不同的程序，反复执行，直到所有任务完成。时间片必须是时钟中断周期的倍数，因为它依靠时钟周期中断实现。</p><p>现在时间片为1，即每隔一秒切换一次，各个时间应该如下：（仍然假设各个任务为 a b c）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>4、<br>1、在相同时间到达，运行相同时间的任务</p><p>2、在不同时间到达，但是任务的到达顺序是运行时间由短到长。</p><p>这两种类型的工作负载的周转时间都相同。</p><p>5、</p><p>每个工作的工作负载和量子长度相同时，SJF与RR提供相同的响应时间。</p><p>6、</p><p>SJF的其它工作（除了第一份工作，因为它是第一个运行，响应时间为0）响应时间会随着工作长度的增加而增加。</p><p>现在我假设三个工作（依然是 a b c），我将从100 200 300 开始不断的增加长度，使用模拟程序查看平均响应时间，得到结果如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174120557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"> </p><p>可以看到，平均响应时间确实是随着工作长度的增加而增加。</p><p>7、</p><p>显然，随着量子长度的增加，RR的响应时间也会随着增加。</p><p>最坏情况：首先我们假设这N个工作的到达顺序为从最长的到最短的，假设它们的序号为1,2，3…N，量子长度为S</p><p>且最长的工作（序号为1）的工作长度为小于等于量子长度即</p><p>1&lt;=S;</p><p>那么，这组工作的响应时间即是前N-1个工作长度的总合，即为</p><p>1+2+3+4+…+（N-1）</p><p>（注意这里的数字1,2,3,4表示的是工作的序号，不是工作长度，它们的工作长度顺序是1&gt;2&gt;3&gt;4..）</p><p>即最坏情况下的响应时间是<strong>除了长度最短的工作</strong>的<strong>所有工作长度的总合</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;a href=&quot;#操作系统导论第七章：进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;/a&gt;操作系统导论第七章：进程调度&lt;/h1&gt;&lt;p&gt;操作系统该如何决定切换进程？如何运行进程使得效率最大化？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第七章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第六章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操行系统导论第六章/</id>
    <published>2019-10-08T08:55:42.863Z</published>
    <updated>2019-10-08T08:55:42.864Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第六章：受限直接运行"><a href="#操作系统导论第六章：受限直接运行" class="headerlink" title="操作系统导论第六章：受限直接运行"></a>操作系统导论第六章：受限直接运行</h1><p>第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。<br>然而这样带来了一些问题：<br>1、如何在不增加系统开销的情况下实现虚拟化？<br>2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）</p><p>操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。</p><a id="more"></a><h2 id="基本技巧-受限直接运行"><a href="#基本技巧-受限直接运行" class="headerlink" title="基本技巧:受限直接运行"></a>基本技巧:受限直接运行</h2><p>为了使程序尽可能快地运行，只需直接在CPU上运行程序即可，但是为了解决上面提到的问题，我们必须给予运行程序一些限制。</p><h2 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h2><p>当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中，找到入口点（main（）），跳转到哪里，并开始运行用户的代码。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>为了限制进程的运行，硬件 通过提供不同的执行模式来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源（操作系统就处于这一模式下）。<br>但是在用户模式下，给予一些方式使得程序能够短暂进入内核模式是有必要的。因为大部分的应用程序都需要进行I/O和其他相关操作。<br>现代硬件提供了用户程序执行系统调用的能力。<br>要执行系统调用，程序必须执行特殊的陷阱指令。该指令同时跳入内核并将特权级别提升到内核模式。完成所需的工作后，操作系统调用一个特殊的从陷阱返回的指令，应用程序回到用户模式。</p><h2 id="在进程中切换"><a href="#在进程中切换" class="headerlink" title="在进程中切换"></a>在进程中切换</h2><p>当一个进程在CPU上运行时，就意味着操作系统没有运行，那么操行系统应该如何决定停止一个进程并开始另一个进程？显然，一个没有运行的操作系统是无法执行任何操作的。<br>那么，操作系统应该如何在进程运行时重获CPU的控制权？<br>协作方式：等待系统调用。<br>过去系统采用这种等待进程进行系统调用的方式，当进程进行系统调用时，将控制权交给操作系统。<br>但是，如果一个进程永远不进行系统调用，也不出错，那么这种方式就无法解决问题了。<br>为此操作系统采用时钟中断来重获控制权。</p><h2 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h2><p>如果操作系统决定切换进程，那么操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核指针，然后恢复即将切换的程序的上下文，并切换栈。<br>通过切换栈，内核在进入切换代码调用时，是被中断进程的上下文，在返回时，是另一个进程的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;a href=&quot;#操作系统导论第六章：受限直接运行&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;/a&gt;操作系统导论第六章：受限直接运行&lt;/h1&gt;&lt;p&gt;第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。&lt;br&gt;然而这样带来了一些问题：&lt;br&gt;1、如何在不增加系统开销的情况下实现虚拟化？&lt;br&gt;2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）&lt;/p&gt;
&lt;p&gt;操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第六章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第五章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/25/操作系统导论第五章/</id>
    <published>2019-09-24T17:18:23.188Z</published>
    <updated>2019-09-24T17:20:08.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第五章：进程API"><a href="#操作系统导论第五章：进程API" class="headerlink" title="操作系统导论第五章：进程API"></a>操作系统导论第五章：进程API</h1><a id="more"></a><h2 id="UNIX的系统调用"><a href="#UNIX的系统调用" class="headerlink" title="UNIX的系统调用"></a>UNIX的系统调用</h2><p>UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。</p><p>父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。</p><h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><strong><em>先贴一段简单的调用fork函数的代码</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,world.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am child\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am parent\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>运行结果是：</p><p><img alt data-src="https://img-blog.csdnimg.cn/20190925010803571.png"></p><p>可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。<br>说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。<br>注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。</p><h2 id="exec函数调用"><a href="#exec函数调用" class="headerlink" title="exec函数调用"></a>exec函数调用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">execle(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">execlp(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *m[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(<span class="string">"/bin/ls"</span>,m,<span class="literal">NULL</span>);</span><br><span class="line">execv(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line">execvp(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec（）函数族有六个变体<br>根据参数类型，大体可以分为两类：<br>•    以 list 可变参数传参<br>•    execl<br>•    execlp<br>•    execle<br>•    以 vector 数组传参<br>•    execv<br>•    execvp<br>•    execve<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190925011659188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>各个函数变体参数如上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;a href=&quot;#操作系统导论第五章：进程API&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;/a&gt;操作系统导论第五章：进程API&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第五章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第四章作业解题报告</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/24/操作系统导论第四章模拟作业解题报告/</id>
    <published>2019-09-24T10:11:38.061Z</published>
    <updated>2019-09-24T16:45:32.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第四章：进程"><a href="#操作系统导论第四章：进程" class="headerlink" title="操作系统导论第四章：进程"></a>操作系统导论第四章：进程</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程就是运行中的程序</p><h2 id="一台机器上如何同时运行多个程序？"><a href="#一台机器上如何同时运行多个程序？" class="headerlink" title="一台机器上如何同时运行多个程序？"></a>一台机器上如何同时运行多个程序？</h2><p><strong><em>这里的关键问题是：如何提供有许多CPU的假象？</em></strong></p><p>我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？</p><p>操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。</p><h1 id="模拟作业"><a href="#模拟作业" class="headerlink" title="模拟作业"></a>模拟作业</h1><p>操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载：</p><p><a href="http://http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html" target="_blank" rel="noopener">操作系统导论homework</a>，加载时间可能会常一些，正常等待即可。</p><p>然后从该网站上下载本章需要的作业程序：<em>process-run.py</em>，</p><p>解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。</p><p>博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。</p><p>下面是本章作业1-5题的个人解答，只供参考：</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>1、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180655603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>-c检查：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019092418071355.png"></p><p>和预期相符。</p><p>2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1.</p><p>所以完成这两个进程需要时间为 10；</p><p>检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180729945.png"></p><p>预期相符。</p><p>3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1.</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180754924.png"></p><p>从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。</p><p>4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180820315.png"></p><p>与预期相符</p><p>5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180834685.png"></p><p>与预期相符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第四章：进程&quot;&gt;&lt;a href=&quot;#操作系统导论第四章：进程&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第四章：进程&quot;&gt;&lt;/a&gt;操作系统导论第四章：进程&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="第四章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/15/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/15/新文档/</id>
    <published>2019-08-15T13:42:39.129Z</published>
    <updated>2019-08-15T13:42:39.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的foreach语法"><a href="#java中的foreach语法" class="headerlink" title="java中的foreach语法"></a>java中的foreach语法</h1><p>形式：for(x:a)<br>例如：<br>   <code>int  a[10], x;</code><br>    <code>for(x:a)</code><br>表示将a数组中的每个元素按下标索引的顺序赋值给x；</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的foreach语法&quot;&gt;&lt;a href=&quot;#java中的foreach语法&quot; class=&quot;headerlink&quot; title=&quot;java中的foreach语法&quot;&gt;&lt;/a&gt;java中的foreach语法&lt;/h1&gt;&lt;p&gt;形式：for(x:a)&lt;br&gt;例如：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/02/index/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/02/index/</id>
    <published>2019-08-01T19:34:51.000Z</published>
    <updated>2019-08-01T19:34:51.539Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+github 搭建个人博客</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hexo+github 搭建个人博客/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-08-01T19:20:39.275Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://shenqidaxiansheng.github.io/">博主的博客</a><br>觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号</p><ol><li>注册github账号，你可以去这里注册：<a href="https://github.com/" target="_blank" rel="noopener">github登陆界面</a>，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到</li><li>注册号github账号后，就可以去新建一个仓库，：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802012834196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>如图点击new按钮，新建一个仓库，到了这个页面：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802013358361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io<br>新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。</li><li>下载git，可以去这里下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git下载地址</a>，点击download就可以下载了，下载完成安装就可以了</li><li>然后我们再安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2>前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014643948.png"><br>创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014955292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>打开git bash ，不出意外你将得到这个界面：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802031455315.jpg"><br>这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成<br>输入以下代码安装hexo：<br><code>npm install hexo -g</code><br>安装完成后，输入<br><code>hexo init</code><br>完成初始化<br>##关键一步：将hexo和GitHub上创建的仓库联系起来<br>网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦<br>首先，我们先输入以下命令：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.</span> ssh</span><br></pre></td></tr></table></figure><p>如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥<br>输入以下命令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"邮件地址"</span></span><br></pre></td></tr></table></figure><p>邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\id_rsa.pub，例如博主的这个文件就在这：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802020710806.png"><br>用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：<br>点击 new ssh key，是是啊撒大声地大大大是是是<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802021007911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。<br>有了ssh秘钥就可以把本地文件和github上的仓库联系起来<br>继续在gitbash上执行如下命令：<br>    <code>git config --global user.name &quot;username&quot;// 你的github用户名，非昵称</code><br>    <code>git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code><br>这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。</p><p>##将本地博客上传到github上<br>输入以下命令：<br>    <code>hexo g</code><br>    <code>hexo s</code><br>然后在游览器上打开网址：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。<br>然后输入以下命令：<br>    <code>hexo clean</code><br>    <code>hexo g</code><br>    <code>hexo d</code><br>hexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。<br>输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）<br>利用hexo大家博客完成</p><p>##写博客<br>博客搭好后，我们如何写博客并且上传到自己的博客页面？<br>先按照这个路径点开这个文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802023807653.png"><br>这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，<br>执行命令：<br>    <code>hexo new page &quot;my-first-blog&quot;</code><br>就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（<a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">makedown下载地址</a>）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。<br>当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了<br>(╥╯^╰╥)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://shenqidaxiansheng.github.io/&quot;&gt;博主的博客&lt;/a&gt;&lt;br&gt;觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺&lt;/p&gt;
    
    </summary>
    
      <category term="搭建个人博客及美化" scheme="http://shenqidaxiansheng.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96/"/>
    
    
      <category term="hexo" scheme="http://shenqidaxiansheng.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://shenqidaxiansheng.github.io/tags/github/"/>
    
      <category term="个人博客" scheme="http://shenqidaxiansheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>四六级词汇学习笔记</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/四六级词汇/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-07-30T12:39:08.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四六级词汇学习笔记"><a href="#四六级词汇学习笔记" class="headerlink" title="四六级词汇学习笔记"></a>四六级词汇学习笔记</h2><a id="more"></a><p>英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。</p><h2 id="前缀示例："><a href="#前缀示例：" class="headerlink" title="前缀示例："></a>前缀示例：</h2><p>deriver from –源自于<br>deviate from –偏离(deviate脱离）<br>前缀：de -&gt; down(下降)<br>derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于<br>decrease(减少)<br>decline(n.下降，vt 婉拒）<br>(同义词 refus ，reject)<br>前缀re 表示again再一次 或者 back返回<br>retell 再讲一遍<br>return 返回，回报<br>词根fuse = flow 表示流动<br>refuse 表示流回去（拒绝）<br>ject-词根-扔<br>reject 扔回去（强烈的拒绝）</p><p>steam from 也表示源自于的意思<br>steam 名词-根茎<br>originate from 源自于</p><p>discount：n.折扣，v.认为..不重要<br>前缀-dis-表示否定<br>count计算，discount即表示打折扣</p><p>account：n.账目，赊账<br>前缀-ac-强调作用<br>a+辅音<br>（aeiou五个字母为元音字母，其余为辅音字母）<br>（元音字母可以替换但是意思不变，例如：begin-began-begun<br>Man-Men）<br>count-计数，数数<br>counter ：计算器，计数器，柜台<br>作形容词还可表示相反的<br>作副词表示相反地<br>作动词表示反对<br>（OTC：over the counter）<br>counterbalance:制衡（从相反的方向平衡）</p><p>后缀er（和or相同）-表示人或者物）<br>cooker（厨具）<br>tractor（拖拉机）</p><h2 id="后缀示例："><a href="#后缀示例：" class="headerlink" title="后缀示例："></a>后缀示例：</h2><p>origin-n.起源-后缀ate<br>original-adj.原始的-后缀al</p><p>fluctuate 起伏不定<br>后缀-ate：<br>1、名词，例如：graduate毕业生，candidate候选人<br>2、动词，例如：graduate 毕业（动词）<br>3、形容词，例如：private<br>前缀：flu流动<br>fluent：流利的<br>后缀：ent=ant 表示形容词或者名词后缀<br>account，servant，<br>fluid<br>名词 液体，形容词流动的<br>反义词 solid<br>influential<br>前缀：in 表在里面<br>也可表否定，这时一般做形容词前缀</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四六级词汇学习笔记&quot;&gt;&lt;a href=&quot;#四六级词汇学习笔记&quot; class=&quot;headerlink&quot; title=&quot;四六级词汇学习笔记&quot;&gt;&lt;/a&gt;四六级词汇学习笔记&lt;/h2&gt;
    
    </summary>
    
      <category term="英语学习" scheme="http://shenqidaxiansheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="英语学习," scheme="http://shenqidaxiansheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="四六级" scheme="http://shenqidaxiansheng.github.io/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hello-world/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hello-world/</id>
    <published>2019-07-29T07:02:22.715Z</published>
    <updated>2019-07-29T08:23:27.991Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
