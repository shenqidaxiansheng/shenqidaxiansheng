<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只神奇的DXS</title>
  
  <subtitle>一名计算机学生的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenqidaxiansheng.github.io/"/>
  <updated>2020-11-23T13:44:15.379Z</updated>
  <id>http://shenqidaxiansheng.github.io/</id>
  
  <author>
    <name>Jing Hua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里一面/二面</title>
    <link href="http://shenqidaxiansheng.github.io/2020/11/20/%E9%98%BF%E9%87%8C%E4%B8%80%E9%9D%A2%E4%BA%8C%E9%9D%A2/"/>
    <id>http://shenqidaxiansheng.github.io/2020/11/20/阿里一面二面/</id>
    <published>2020-11-20T13:10:15.000Z</published>
    <updated>2020-11-23T13:44:15.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><p>不得不说阿里不亏是国内最顶级的Java技术公司，问的问题很有深度，关于netty方面和面试官讲底层他也都能听懂，面试体验非常好。</p><a id="more"></a><h2 id="问题1：类加载过程"><a href="#问题1：类加载过程" class="headerlink" title="问题1：类加载过程"></a>问题1：类加载过程</h2><p>关于Java虚拟机方面，第一个问题就挺好</p><p>类加载分为以下 5 个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>验证：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p><h2 id="问题2：看过深入理解Java虚拟机不？说说Java运行时内存结构"><a href="#问题2：看过深入理解Java虚拟机不？说说Java运行时内存结构" class="headerlink" title="问题2：看过深入理解Java虚拟机不？说说Java运行时内存结构"></a>问题2：看过深入理解Java虚拟机不？说说Java运行时内存结构</h2><p>很幸运，本人曾经完整看过《深入理解Java虚拟机》这本书，很好的一本书，推荐去看。</p><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><p>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</p><p>Execution engine（执行引擎）：执行classes中的指令。</p><p>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</p><p>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</p><p>运行时数据区域包括：</p><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；<br>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<br>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<br>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<br>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><h2 id="问题3：说说同步、异步、阻塞、非阻塞的区别"><a href="#问题3：说说同步、异步、阻塞、非阻塞的区别" class="headerlink" title="问题3：说说同步、异步、阻塞、非阻塞的区别"></a>问题3：说说同步、异步、阻塞、非阻塞的区别</h2><p>考验对网络编程模型的理解，本人就是做网络编程这一块的，答起来挺轻松</p><p>同步异步</p><p>同步指的是用户进程/线程触发IO操作并等待<strong>或者轮询</strong>的去查看IO操作是否就绪，而异步是指用户进程触发IO操作后便去做自己的事情，之后等待OS通知IO操作已完成。</p><p><strong>同步异步是指的是线程是否主动去查看IO操作是否完成，主动的是同步，非主动的是异步。</strong></p><p>阻塞非阻塞</p><p>阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取不同的方式，阻塞方式下读取或者写入方法将一直等待，而非阻塞方式读取或者写入方法则会立即返回一个状态值。</p><h2 id="问题4算法题：玩过开心消消乐吗？给你一个字符串，相同的消去，然后左移，你怎么实现他？"><a href="#问题4算法题：玩过开心消消乐吗？给你一个字符串，相同的消去，然后左移，你怎么实现他？" class="headerlink" title="问题4算法题：玩过开心消消乐吗？给你一个字符串，相同的消去，然后左移，你怎么实现他？"></a>问题4算法题：玩过开心消消乐吗？给你一个字符串，相同的消去，然后左移，你怎么实现他？</h2><p>比较简单，用栈实现，跟栈顶元素相同的不入栈，并从栈顶弹出元素，做标记，接下来连续跟这个字符相同的都不入栈。</p><h2 id="问题5：知道epoll吗？"><a href="#问题5：知道epoll吗？" class="headerlink" title="问题5：知道epoll吗？"></a>问题5：知道epoll吗？</h2><p>回调函数，实现异步操作的，正常答。</p><h2 id="问题6：netty和NIO的关系是什么"><a href="#问题6：netty和NIO的关系是什么" class="headerlink" title="问题6：netty和NIO的关系是什么"></a>问题6：netty和NIO的关系是什么</h2><p>正常答，挺简单，netty基于NIO实现。</p><h2 id="问题7：接下来就是聊聊自己做的项目了，不多说"><a href="#问题7：接下来就是聊聊自己做的项目了，不多说" class="headerlink" title="问题7：接下来就是聊聊自己做的项目了，不多说"></a>问题7：接下来就是聊聊自己做的项目了，不多说</h2><p>大概介绍所做项目即可。</p><p>还有一些问题，不过没记住的问题大部分都答出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;面试总结&quot;&gt;&lt;a href=&quot;#面试总结&quot; class=&quot;headerlink&quot; title=&quot;面试总结&quot;&gt;&lt;/a&gt;面试总结&lt;/h1&gt;&lt;p&gt;不得不说阿里不亏是国内最顶级的Java技术公司，问的问题很有深度，关于netty方面和面试官讲底层他也都能听懂，面试体验非常好。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenqidaxiansheng.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenqidaxiansheng.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程</title>
    <link href="http://shenqidaxiansheng.github.io/2020/11/18/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://shenqidaxiansheng.github.io/2020/11/18/Java网络编程/</id>
    <published>2020-11-18T05:18:11.000Z</published>
    <updated>2020-11-23T13:26:16.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><p>本人整理的关于网络编程的知识点、包含所有的编程细节。</p><a id="more"></a><h2 id="同步异步、阻塞非阻塞"><a href="#同步异步、阻塞非阻塞" class="headerlink" title="同步异步、阻塞非阻塞"></a>同步异步、阻塞非阻塞</h2><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p>同步指的是用户进程/线程触发IO操作并等待<strong>或者轮询</strong>的去查看IO操作是否就绪，而异步是指用户进程触发IO操作后便去做自己的事情，之后等待OS通知IO操作已完成。</p><p><strong>同步异步是指的是线程是否主动去查看IO操作是否完成，主动的是同步，非主动的是异步。</strong></p><h3 id="阻塞非阻塞"><a href="#阻塞非阻塞" class="headerlink" title="阻塞非阻塞"></a>阻塞非阻塞</h3><p>阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取不同的方式，阻塞方式下读取或者写入方法将一直等待，而非阻塞方式读取或者写入方法则会立即返回一个状态值。</p><p><strong>阻塞和非阻塞是进程在等待IO处理结果的时候是否被挂起，等待的时候被挂起是阻塞，没有被挂起是非阻塞。</strong></p><p>所以异步必定是非阻塞的，异步阻塞没有意义，同步才分阻塞和非阻塞。</p><p>同步阻塞就是一直等待IO操作完成。</p><p>同步非阻塞就是轮询查看IO操作是否完成（每一次轮询都能得到状态值）没有堵塞，可以去干别的事。</p><p>异步非阻塞就是不等待IO操作的结果，线程可以去干别的事，等待OS通知IO操作是否完成。</p><h2 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a>BIO、NIO、AIO</h2><h3 id="BIO（JDK1-4版本之前用的"><a href="#BIO（JDK1-4版本之前用的" class="headerlink" title="BIO（JDK1.4版本之前用的)"></a>BIO（JDK1.4版本之前用的)</h3><p>同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务端就需要开启一个线程来进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，可通过线程池机制进行优化。</p><p>BIO适用于连接数小且比较固定的架构，这种方式对服务器资源要求比较高。</p><p>线程池优化：把客户端连接通过submit/execute 到threadpool，让线程池和客户端连接。</p><p>BIO编程过程</p><p>1、服务器端启动一个serversocket</p><p>2、客户端创建socket与服务端连接，服务器创建一个线程与客户端对应（一般用线程池）</p><p>3、客户端发出请求后，先咨询服务器是否有响应，如果没有则会等待，或者被拒绝</p><p>4、如果有响应，客户端线程会等待请求结束后，在继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1、创建线程池</span><br><span class="line">     ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">     //2、创建serversocket</span><br><span class="line">     ServerSocket serverSocket = new ServerSocket(6666);</span><br><span class="line">     //3、循环监听端口</span><br><span class="line">     while (true)&#123;//循环等待连接</span><br><span class="line">         Socket socket = serverSocket.accept();//有人来连接</span><br><span class="line">         //有客户端连接就创建线程与之通信</span><br><span class="line">         //线程池</span><br><span class="line">         service.execute(new Handler(socket, num++));</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>同步非阻塞模型，NIO本身是基于事件驱动来完成的，主要是为了解决BIO的大并发问题。</p><p>当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器（selector）上，当这个多路复用器进行轮询的时候，发现连接上面有请求的话，就会开启一个线程进行处理，也就是<strong>一个请求一个线程</strong>。</p><p><strong>每一个channel 和客户端之间都有一个buffer，channel和客户端是通过buffer来交换数据的。</strong></p><p>NIO是面向缓冲区编程的，数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加处理过程的灵活性，，使用它可以提供非阻塞式的高伸缩性网络。</p><p>缺点：在NIO的处理方式中，当开启一个线程来处理请求，可能还会等待后续资源的连接，这个开启的线程实际上是被阻塞了，当并发上来了，还是会存在和BIO一样的问题。</p><p>过程：</p><p>1、当客户端连接时，会通过serversocketChannel得到SocketChannel。</p><p>2、将socketChannel注册到Selector上，register(Selector sel, int ops), 一个selector可以注册多个channel</p><p>3、注册后返回一个SeletionKey，会和该Selector进行关联（集合）。</p><p>4、Selector进行监听（调用select方法）， 返回有事件发生的通道的个数.</p><p>5、进一步得到各个SelectionKey（有事件发生的通道的对应selectionkey）</p><p>6、通过selectionkey反向得到Socketchannel，调用方法channel();</p><p>7、可以通过得到的channel完成对业务的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverchannel.register()函数有两个参数，第一个是注册的selector，第二个是状态编码，</span><br><span class="line">状态编码有四个：</span><br><span class="line">OP_ACCept,连接成功的标志</span><br><span class="line">OP_READ：可以读的标记</span><br><span class="line">OP_WRITER：可以写的标记</span><br><span class="line">OP_CONNET:连接建立后的标志</span><br></pre></td></tr></table></figure><p><img alt="image-20201003173526351" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201003173526351.png"></p><h3 id="AIO模型"><a href="#AIO模型" class="headerlink" title="AIO模型"></a>AIO模型</h3><p>异步非阻塞（Asynchronous：IO）的编程方式，与NIO不同，当进行读写操作时，只需直接调用API的read或write方法即可，这两种方法皆是异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法缓冲区，并通知应用程序，对于写操作而言，当操作系统将write方法传递的流写入完毕时，会主动通知应用程序。即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。</p><p>异步非阻塞，服务器实现为一个有效的请求对应一个线程，客户端I/O请求都是由 OS先完成了再通知服务器应用去启动线程进行处理。</p><p>AIO方式用于连接数目多且比较长的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7之后支持。</p><p>过程：当客户端发起请求时，会建立一个AsynchronousSocketChannel（通道）</p><p>如图：（handle充当操作系统的角色）</p><p><img alt="image-20201003184553630" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201003184553630.png"></p><h2 id="TCPServer"><a href="#TCPServer" class="headerlink" title="TCPServer"></a>TCPServer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建serversocket，指定监听的端口</span><br><span class="line">        ServerSocket serverSocket = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            serverSocket = new ServerSocket(9999);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        //accept监听端口</span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">        InputStream is;</span><br><span class="line">        //字节输入流获取输入的信息</span><br><span class="line">        is = accept.getInputStream();</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        //管道流存储输入流，防止乱码</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br><span class="line">        int read = is.read(buffer);</span><br><span class="line">        //将读取到的流写到管道流，方便转换</span><br><span class="line">        byteArrayOutputStream.write(buffer,0,read);</span><br><span class="line">        System.out.println(byteArrayOutputStream.toString());</span><br><span class="line">        //关闭流和连接</span><br><span class="line">        byteArrayOutputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCPclient"><a href="#TCPclient" class="headerlink" title="TCPclient"></a>TCPclient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //指定服务器的IP地址</span><br><span class="line">        InetAddress serverip = InetAddress.getByName(&quot;127.0.0.1&quot;);</span><br><span class="line">        //指定端口号，建立连接</span><br><span class="line">        Socket socket =new Socket(serverip, 9999);</span><br><span class="line">        //使用字节流传输数据,输出流对象连接到socket的输出流</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(&quot;Hi, server&quot;.getBytes());</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDPReceive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * UDP接收端，跟发送端差不多，差别是要指定接受的端口(阻塞监听接受)</span><br><span class="line"> */</span><br><span class="line">public class UDPReceive &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建socket</span><br><span class="line">        DatagramSocket socket = new DatagramSocket(9999);//指定监听的端口</span><br><span class="line">        byte[] buffer = new byte[1024];//创建缓存区存储接受到的包</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//指定接受包存储的信息</span><br><span class="line">        //接受包</span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        //输出结果看看</span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(packet.getPort());</span><br><span class="line">        System.out.println(packet.getData().length);</span><br><span class="line">        System.out.println(new String(packet.getData(),0,packet.getLength()));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDPSent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * UDP 就是一个创建包、发送包、拆解包的过程(多路复用/分解)，只有发送端和接受端</span><br><span class="line"> */</span><br><span class="line">public class UDPSent &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //创建一个socket</span><br><span class="line">        DatagramSocket socket = new DatagramSocket();</span><br><span class="line">        //建立包</span><br><span class="line">        String msg = &quot;你好啊接受端&quot;;</span><br><span class="line">        InetAddress localhost = InetAddress.getByName(&quot;localhost&quot;);//指定接收端的IP</span><br><span class="line">        int port = 9999; //指定接受端的接口</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(msg.getBytes(),0, msg.length(), localhost, port);</span><br><span class="line">        //发送包</span><br><span class="line">        socket.send(packet);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP双人聊天"><a href="#UDP双人聊天" class="headerlink" title="UDP双人聊天"></a>UDP双人聊天</h2><p>聊天发送线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//talksent</span><br><span class="line">public class TalkSent implements Runnable&#123;</span><br><span class="line">    private int to_port;</span><br><span class="line">    private String to_ip;</span><br><span class="line">    private DatagramSocket socket;</span><br><span class="line"></span><br><span class="line">    public TalkSent(int to_port, String to_ip) &#123;</span><br><span class="line">        this.to_port = to_port;</span><br><span class="line">        this.to_ip = to_ip;</span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new DatagramSocket();</span><br><span class="line">        &#125; catch (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            String data = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                data = reader.readLine();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            byte[] datas = data.getBytes();</span><br><span class="line">            InetAddress localhost = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                localhost = InetAddress.getByName(to_ip);//指定接收端的IP</span><br><span class="line">            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            DatagramPacket packet = new DatagramPacket(datas,0,datas.length, localhost, to_port);</span><br><span class="line">            try &#123;</span><br><span class="line">                socket.send(packet);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聊天接收线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.hua.socket;</span><br><span class="line"></span><br><span class="line">import javax.sound.midi.Receiver;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line"></span><br><span class="line">public class TalkReceive implements Runnable&#123;</span><br><span class="line">    private int receive_port;</span><br><span class="line">    private DatagramSocket socket;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public TalkReceive(int receive_port,String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.receive_port = receive_port;</span><br><span class="line">        try &#123;</span><br><span class="line">            socket = new DatagramSocket(this.receive_port);</span><br><span class="line">        &#125; catch (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                //接受数据包</span><br><span class="line">                DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);</span><br><span class="line">                socket.receive(packet);</span><br><span class="line">                String data = new String(buffer,0,buffer.length);</span><br><span class="line">                System.out.println(name + &quot;:&quot; + data);</span><br><span class="line">                if(data.equals((&quot;bye&quot;)))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个聊天对象（聊天端）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StudentTalk &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new TalkSent(9999, &quot;localhost&quot;)).start();</span><br><span class="line">        new Thread(new TalkReceive(8888,&quot;老师&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TeacherTalk &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new TalkSent(8888, &quot;localhost&quot;)).start();</span><br><span class="line">        new Thread(new TalkReceive(9999,&quot;学生&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="netty框架"><a href="#netty框架" class="headerlink" title="netty框架"></a>netty框架</h1><h2 id="netty介绍"><a href="#netty介绍" class="headerlink" title="netty介绍"></a>netty介绍</h2><p>1、netty是由JBOSS公司提供的一个Java开源框架，现为github上的一个独立项目</p><p>2、netty是一个<strong>异步</strong>的、<strong>基于事件驱动</strong>的<strong>网络</strong>应用框架、用以快速开发高性能、高可靠性的网络IO程序。</p><p>3、netty主要针对TCP协议下，面向client端的高并发应用，或者peer-to-peer场景下的大量数据持续传输的应用。</p><p>4、netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景</p><p>5、要透彻理解netty，需要先学习NIO，我们才能阅读netty源码。</p><img alt="image-20201006211803086" style="zoom:80%;" data-src="F:\blog\hexo\source\assets\image-20201006211803086.png"><h2 id="netty应用场景"><a href="#netty应用场景" class="headerlink" title="netty应用场景"></a>netty应用场景</h2><p>1、应有于分布式系统</p><p>2、游戏行业</p><p>3、大数据领域</p><h2 id="NIO三大组件"><a href="#NIO三大组件" class="headerlink" title="NIO三大组件"></a>NIO三大组件</h2><p>1、每一个channel都对应一个buffer</p><p>2、selector对应一个线程，一个线程对应多个channel</p><p>3、该图反应了有三个channel注册到了该selector</p><p>4、程序切换到哪一个channel是由事件决定的，Even就是一个重要的概念</p><p>5、selector会根据不同的事件，在各个channel上切换</p><p>6、buffer就是一个内存块，底层是一个数组</p><p>7、数据的读取写入是通过buffer，而BIO是数据流，不能双向；buffer可读可写，但是需要用一个重要的方法flip()进行切换。</p><p>8、channel是双向的，可以返回底层操作系统的情况，比如linux，底层的操作系统通道就是双向的</p><p>NIO核心组件关系图：</p><img alt="image-20201007205220842" style="zoom:80%;" data-src="F:\blog\hexo\source\assets\image-20201007205220842.png"><h3 id="1、buffer"><a href="#1、buffer" class="headerlink" title="1、buffer"></a>1、buffer</h3><p>缓冲区实际上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。channel提供从文件、网络读取数据的渠道，但是读取或者写入数据都要经由buffer，如图</p><img alt="image-20201007211036304" style="zoom:50%;" data-src="F:\blog\hexo\source\assets\image-20201007211036304.png"><p>在NIO中，buffer是一个顶层父类，是一个抽象类</p><p><img alt="image-20201007211324447" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201007211324447.png"></p><p>用得最多的是bytebuffer。</p><p>四个标志位：</p><p>capacity//容量</p><p>position位置</p><p>limit限制</p><p>mark读写标志</p><p><strong>一旦flip调用，那么limit就会等于写进来的position，position变成0</strong></p><p>buffer 常用AIPI</p><p><img alt="image-20201007212821368" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201007212821368.png"></p><p>buffer的一些注意事项和细节：</p><p>1、put()什么类型的数据，就get()什么类型，否则会抛出异常</p><p>2、可以设置buffer成只读，获得一个只读buffer，</p><p><code>ByteBuffer bytebuffer = buffer.asReadOnlyBuffer();</code></p><h4 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h4><p>NIO提供了MappedByteBuffer，<strong>可以让文件直接在内存（堆外的内存）中进行修改，而如何同步文件由NIO来完成。操作系统不需要再拷贝一次，性能会比较高</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//这里文件读写应该使用RandomAccessFile，</span><br><span class="line">// 因为RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。</span><br><span class="line">RandomAccessFile fileOutputStream = new RandomAccessFile(&quot;test&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line">/**</span><br><span class="line"> * 第一个参数是Mapmod，使用的读写模型</span><br><span class="line"> * 第二个参数是修改的起始位置</span><br><span class="line"> * 第三个参数是映射到内存的大小，即test文件的多少个字节映射到内存</span><br><span class="line"> */</span><br><span class="line">MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 5);</span><br><span class="line">mappedByteBuffer.put(0, (byte)9);</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure><h3 id="2、channel"><a href="#2、channel" class="headerlink" title="2、channel"></a>2、channel</h3><p>1、NIO的通道类似于流，但有些区别</p><ul><li>通道可以进行读和写，而流只能进行读或者写也即是输入流和输出流</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲区读数据，也可以写数据到缓冲</li></ul><p>2、channel在NIO中是一个接口</p><p>3、常用的channel子类有</p><p>filechannel、datagramchannel、serversocketchannel、socketchannel。</p><p>4、filechannel用于文件的数据读写，datagramchannel用于UDP数据的读写，</p><p>Serversocketchannel和Socketchannel用于TCP的读写。</p><h4 id="Filechannel"><a href="#Filechannel" class="headerlink" title="Filechannel"></a>Filechannel</h4><img alt="image-20201007215732038" style="zoom:80%;" data-src="F:\blog\hexo\source\assets\image-20201007215732038.png"><h3 id="3、selector选择器-多路复用器"><a href="#3、selector选择器-多路复用器" class="headerlink" title="3、selector选择器/多路复用器"></a>3、selector选择器/多路复用器</h3><p>selector能够检测多个注册的通道上是否有事件发生（多个channel可以以事件的方式注册到selector），如果有事件发生，便获取事件然后针每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p><p>只有在连接/通道 真正有事件发生时，才会进行读写，就大大地减小了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，避免了线程上下文切换造成的开销。</p><p><strong>特点说明</strong></p><ul><li>netty的IO线程NioEventloop聚合了Selector，可以同时并发处理成百上千个客户端连接</li><li>当线程从某客户端Socket通道进行读写数据时，若没有数据可用时，该线程可以进行其它任务</li><li>线程通常将非阻塞IO的空闲时间用于其它通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道</li><li>由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞造成的线程挂起。</li><li>一个I/O线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞I/O一个连接一个线程的模型，架构的性能和弹性伸缩能力得到了极大提升。</li></ul><p><img alt="image-20201008202053360" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201008202053360.png"></p><p><img alt="image-20201008203724226" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201008203724226.png"></p><p>对上图过程的说明</p><p>1、当客户端连接时，会通过serversocketChannel得到SocketChannel。</p><p>2、将socketChannel注册到Selector上，register(Selector sel, int ops), 一个selector可以注册多个channel</p><p>3、注册后返回一个SeletionKey，会和该Selector进行关联（集合）。</p><p>4、Selector进行监听（调用select方法）， 返回有事件发生的通道的个数.</p><p>5、进一步得到各个SelectionKey（有事件发生的通道的对应selectionkey）</p><p>6、通过selectionkey反向得到Socketchannel，调用方法channel();</p><p>7、可以通过得到的channel完成对业务的处理</p><h3 id="4、代码示例"><a href="#4、代码示例" class="headerlink" title="4、代码示例"></a>4、代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //通过open获取serversocketchannel，然后将其绑定到端口上</span><br><span class="line">        ServerSocketChannel serverSocketChannel =  ServerSocketChannel.open().bind(new InetSocketAddress(6666));</span><br><span class="line">        //选择serversocketchannel为非阻塞</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        //通过open获取selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        //将serversocketchannel注册到selector上,选择OP_ACCEPT事件</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        //selector循环监听</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //每一秒钟返回一次，注意select返回的是有事件发生的通道个数</span><br><span class="line">            int num = selector.select(1000);</span><br><span class="line">            if(num == 0)&#123;</span><br><span class="line">                System.out.println(&quot;没有事件发生&quot;);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果有事件发生，也就是num大于0,首先获取发生事件的通道集合,通过selectionkey获取</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            //遍历得到的集合,集合的变量由迭代器完成，根据key的事件采取不同的操作</span><br><span class="line">            Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();</span><br><span class="line">            while(selectionKeyIterator.hasNext())&#123;</span><br><span class="line">                //得到集合中的selectionkey</span><br><span class="line">                SelectionKey key = selectionKeyIterator.next();</span><br><span class="line">                if(key.isAcceptable())&#123;//有新的客户端连接</span><br><span class="line">                    //为该连接生成一个channel</span><br><span class="line">                    SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">                    //将该channel注册到selector，设置为读事件,同时要给channel关联一个buffer</span><br><span class="line">                    channel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(1024));</span><br><span class="line">                &#125;</span><br><span class="line">                if(key.isReadable())&#123;//发生读事件，要通过key反向得到channel,强制类型转换，向下转换是没问题的</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    //通过attachment获得绑定的bytebuffer</span><br><span class="line">                     ByteBuffer bytebuffer = (ByteBuffer) key.attachment();</span><br><span class="line">                     channel.read(bytebuffer);</span><br><span class="line">                    System.out.println(&quot;客户端：&quot; + new String(bytebuffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                //集合的遍历，需要移除当前key</span><br><span class="line">                selectionKeyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NIOClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = new InetSocketAddress(&quot;127.0.0.1&quot;, 6666);</span><br><span class="line">        while(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            System.out.println(&quot;循环地尝试连接服务器&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //注意wrap方法，即一步创建数组大小的buffer，并且将里面的元素放入buffer</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(&quot;你好啊NIO服务器&quot;.getBytes());</span><br><span class="line">        //将bytebuffer里面的数据写入通道</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、如何监听是否有客户端连接？</p><p>操作是把serversocketChannel注册到selector上，将事件设置为OP_ACCEPT。</p><p>2、selectionkey</p><p>表示selector和网络通道的注册关系，一共有四种</p><ul><li>int OP_ACCEPT 有新的网络连接可以接受，值为16</li><li>int OP_CONNECT 代表连接已经建立，值为8</li><li>int OP_WRITE 代表写操作，值为4</li><li>int OP_READ 代表读操作,值为1</li></ul><img alt="image-20201009195048172" style="zoom:67%;" data-src="F:\blog\hexo\source\assets\image-20201009195048172.png"><p>3、服务器怎么知道客户端断开连接</p><p>在读事件的时候读到的数据为 -1，就可以知道是客户端断开连接了。</p><p>或者说你读一个断开的客户端发来的数据时，会抛出IO异常，此时服务器就知道客户端断开连接了。</p><h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><p>零拷贝是指从操作系统角度看的，即没有发生CPU拷贝。</p><p>传统的拷贝：（四次拷贝，3次切换）</p><p>硬盘 –(DMA)-&gt; kernelbuffer -&gt;userbuffer-&gt;socketbuffer-&gt;协议栈。</p><p>MMP拷贝（三次拷贝，3次切换）</p><p>kernelbuffer 和userbuffer共享内存，减少一次拷贝</p><p>硬盘 –(DMA)-&gt; kernelbuffer(和userbuffer共享内存）–&gt;socketbuffer-&gt;协议栈。</p><p>不经过userbuff，所以减少一次切换到用户态的次数。</p><p>零拷贝（Sendfile）：(2次拷贝，2次切换（没有经过用户态)）</p><p>硬盘 通过DMA（直接内存拷贝）拷贝到 kernelbuffer，然后从kernelbuff拷贝到协议栈</p><p>注意，kernelbuffer 其实有一次CPU拷贝到socketbuffer，但是信息量很少，比如length、offeset，消耗低，可以忽略。</p><p>NIO的TransferTo()方法使用的是零拷贝.</p><h2 id="Netty高性能架构设计"><a href="#Netty高性能架构设计" class="headerlink" title="Netty高性能架构设计"></a>Netty高性能架构设计</h2><p>不同的线程模型对程序的性能有很大的影响。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>1、传统阻塞的IO服务模型（类似于BIO）</p><p>IO阻塞</p><p>每个独立的连接都需要独立的线程完成数据的输入、处理、返回。</p><p>2、Reactor（反应器模型）</p><ul><li>根据Reactor的数量和处理资源池线程数量的不同，可以由三种典型的实现。</li><li>单Reactor单线程、单Reactor多线程、主从Reactor多线程。</li><li>Netty线程模型基于主从多线程模型改进。</li></ul><p>针对传统阻塞IO的缺点，解决方案：</p><p>1、基于IO复用模型：多个连接共用一个阻塞对象，应用程序只需在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p><p>2、基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后 的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的任务。</p><p>架构图</p><img alt="image-20201010220102174" style="zoom:80%;" data-src="F:\blog\hexo\source\assets\image-20201010220102174.png"><h3 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a>单Reactor单线程</h3><p>架构</p><p><img alt="image-20201017201453964" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201017201453964.png"></p><p>单Reactor单线程，就是监听客户端事件（Reactor）、处理监听的事件(Handle）都在一个线程内完成，这样就带来了一个高并发的问题，多个客户端同时请求的话还是会阻塞。</p><p>这种编程编码简单，清晰明了，但是会带来高并发问题。</p><h3 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h3><p>架构</p><p><img alt="image-20201017210210223" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201017210210223.png"></p><p>Reactor分发事件给对应的Handle，handle只负责响应事件，不做具体的业务处理，通过Read读取数据后，会<strong>分发给后面的work线程池的某个work线程处理业务，并且work线程处理的结果返回给handle</strong>。最后handle得到结果发送给client。</p><p>优点：可以充分利用多核CPU的处理能力</p><p>缺点：多线程会数据共享，访问比较复杂，Reactor（单线程）处理所有的事件监听和响应，在高并发容易出现性能瓶颈。</p><h3 id="多Reactor多线程（主从Reactor模式）"><a href="#多Reactor多线程（主从Reactor模式）" class="headerlink" title="多Reactor多线程（主从Reactor模式）"></a>多Reactor多线程（主从Reactor模式）</h3><p><img alt="image-20201102200707444" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201102200707444.png"></p><h3 id="Netty框架"><a href="#Netty框架" class="headerlink" title="Netty框架"></a>Netty框架</h3><h4 id="1、简单模型"><a href="#1、简单模型" class="headerlink" title="1、简单模型"></a>1、简单模型</h4><p><img alt="image-20201106202736306" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201106202736306.png"></p><p>1）BossGroup线程维护selector，只关注Accept事件，当接受到Accept事件，获取到对应的Socketchannel，封装成NIOSocketChannel并且注册到worker线程（事件循环），并进行维护。</p><p>3）当worker线程监听到selector中通道发生自己感兴趣的事件后，就进行处理（由handler进行处理），注意handler已经加入到通道。</p><h4 id="2、进阶版"><a href="#2、进阶版" class="headerlink" title="2、进阶版"></a>2、进阶版</h4><p><img alt="image-20201106203456066" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201106203827230.png"></p><p>多个主Reactor。</p><h4 id="3、详细版"><a href="#3、详细版" class="headerlink" title="3、详细版"></a>3、详细版</h4><p><img alt="image-20201106203830612" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20201106203830612.png"></p><p>1）netty抽象出两组线程池，BossGroup专门负责接受客户端的连接，WorkGrop专门负责网络的读写。</p><p>2）BossGroup和workerGroup类型都是NIOEventLoopGroup</p><p>3）NIOEventLoopGroup相当于事件循环组，这个组中含有多个事件循环，每一个事件循环是NIOEventLoop。</p><p>4）NIOEventLoop表示一个不断循环的执行处理任务的线程，每个NIOEventLoop都有一个selector，用于监听绑定在其上的socket网络通讯（网络IO）。</p><p>5）NIOEventLoopGroup可以由多个线程，即可以含有多个NIOEventLoop。（一个Group包含多个）</p><p>6）每个Boss NIOEventLoop执行的步骤有3步</p><p>1、轮询accept事件</p><p>2、处理accept事件，与client建立连接，生成NIOSocketChannel，并将其注册到某个worker NIOEventLoop 上的selector</p><p>3、处理任务队列的任务，即runAllTasks。</p><p>7）每个worker NIOEventLoop 循环执行的步骤</p><p>1、轮询read，write事件.</p><p>2、处理I/O事件，即read，write事件，在对应NIOSocketChannel进行处理</p><p>3、处理任务队列的任务，即runAllTakes.</p><p>8）每个Worker NIOEventLoop处理业务时，会使用pipeline(管道)，pipeline中包含了channel，即通过pipeline可以获取到对应通道，管道中维护了很多的处理器，可以用处理器进行对数据的初步处理（数据拦截。数据过滤等）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java网络编程&quot;&gt;&lt;a href=&quot;#Java网络编程&quot; class=&quot;headerlink&quot; title=&quot;Java网络编程&quot;&gt;&lt;/a&gt;Java网络编程&lt;/h1&gt;&lt;p&gt;本人整理的关于网络编程的知识点、包含所有的编程细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE</title>
    <link href="http://shenqidaxiansheng.github.io/2020/11/17/Java%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://shenqidaxiansheng.github.io/2020/11/17/Java知识总结/</id>
    <published>2020-11-17T15:18:11.000Z</published>
    <updated>2020-11-23T13:26:51.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java知识总结"><a href="#Java知识总结" class="headerlink" title="Java知识总结"></a>Java知识总结</h1><p>本人学习过程中整理的大部分Java知识。</p><a id="more"></a><h2 id="1-Java基本常识"><a href="#1-Java基本常识" class="headerlink" title="1.Java基本常识"></a>1.Java基本常识</h2><h3 id="Java三大版本"><a href="#Java三大版本" class="headerlink" title="Java三大版本"></a>Java三大版本</h3><p>Java SE 标准版，桌面程序，控制台开发等</p><p>Java ME 嵌入式开发（凉了）</p><p>Java EE E企业级开发（偏向服务器开发，web端）</p><h3 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h3><p>JDK，Java工具包</p><p>JRE，Java运行时环境</p><p>JVM，Java虚拟机</p><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p>编译器是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;<br> 解释器则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的。</p><p>Java语言先编译，后解释</p><p><img alt="image-20200912125949889" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20200912125949889.png"></p><p>Array类（关于数组的工具类），fill函数（初始化函数；print</p><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><p>面向对象编程的本质就是：以类的方式组织代码，以对象的组织封装数据</p><h3 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装属性，不提供直接访问的实际数据，只提供接口进行访问，即<strong>属性私有</strong></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Java类中只有单继承，没有多继承（即只有一个父类）</p><p>子类可以使用父类除私有之外的属性或方法</p><p>可送给super关键字访问父类的属性或者方法</p><p>super只能出现在子类的方法或者构造方法中，super和this不能同时调用构造方法</p><p>this(本类) 和 super(父类)</p><p><strong>重写</strong></p><p>必须是子类重写父类的非静态方法，方法名必须相同，参数必须相同</p><p>修饰符可以扩大但不能缩小 例如protected可以扩大为public，但是public不能缩小为protected。</p><p>重写都是方法的重写，和属性无关</p><p>父类的引用指向了子类</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是方法的多态，属性没有多态</p><p>存在条件：继承，方法重写、向上转型</p><h4 id="向上转型、向下转型"><a href="#向上转型、向下转型" class="headerlink" title="向上转型、向下转型"></a>向上转型、向下转型</h4><p>向上转型：父类引用指向子类对象。</p><p>向下转型：子类引用指向父类对象，前提是父类对象指向子类对象（也即向上转型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father f1 = <span class="keyword">new</span> Son();   <span class="comment">// 这就叫 upcasting （向上转型)</span></span><br><span class="line"><span class="comment">// 现在 f1 引用指向一个Son对象</span></span><br><span class="line"></span><br><span class="line">Son s1 = (Son)f1;   <span class="comment">// 这就叫 downcasting (向下转型)</span></span><br><span class="line"><span class="comment">// 现在f1 还是指向 Son对象</span></span><br></pre></td></tr></table></figure><h4 id="final-被final修饰的是常量，不能被重写"><a href="#final-被final修饰的是常量，不能被重写" class="headerlink" title="final 被final修饰的是常量，不能被重写"></a>final 被final修饰的是常量，不能被重写</h4><h4 id="instancof-判断子类和父类是否有继承关系"><a href="#instancof-判断子类和父类是否有继承关系" class="headerlink" title="instancof 判断子类和父类是否有继承关系"></a>instancof 判断子类和父类是否有继承关系</h4><h3 id="抽象类（abstract关键字定义"><a href="#抽象类（abstract关键字定义" class="headerlink" title="抽象类（abstract关键字定义)"></a>抽象类（abstract关键字定义)</h3><p>抽象类，包含抽象方法，只定义不实现，由子类实现。抽象类不能new出来。</p><p><strong>抽象类可以包含正常的方法，但是抽象方法必须在抽象类中</strong></p><p>抽象类包含构造方法</p><h3 id="接口（interface关键字定义）"><a href="#接口（interface关键字定义）" class="headerlink" title="接口（interface关键字定义）"></a>接口（interface关键字定义）</h3><p>接口只包含抽象方法</p><p>接口只包含常量的属性，即（static final）</p><p>接口可以多继承，接口的所有方法都要由子类实现</p><p>类可以通过implements实现接口,而且必须实现接口的所有方法</p><p>接口不包含构造方法</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>接口和抽象类都不能实例化<br>都位于继承的顶端，用于被其他实现或继承<br>都包含抽象方法，其子类都必须覆写这些抽象方法</p><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a><strong>抽象类能使用 final 修饰吗？</strong></h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类可以访问外部类的私有变量、方法。</p><p>定义在类内部的静态类，就是<strong>静态内部类</strong>。</p><p>定义在类内部，成员位置上的非静态类，就是<strong>成员内部类</strong>。</p><p>定义在方法中的内部类，就是<strong>局部内部类</strong>。</p><p><strong>匿名内部类</strong>就是没有名字的内部类，日常开发中使用的比较多。</p><p>静态内部类：静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()</p><p>成员内部类：成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()。</p><p><strong>局部内部类</strong>：定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()</p><p>匿名内部类：除了没有名字，匿名内部类还有以下特点：</p><p>匿名内部类必须继承一个抽象类或者实现一个接口。<br>匿名内部类不能定义任何静态成员和静态方法。<br>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。<br>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>优点： 运行期类型的判断，动态加载类，提高代码灵活度。<br>缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p><p>应用：</p><p>反射是框架设计的灵魂。</p><p>jdbc的class.forname（）、spring框架都用了反射机制。</p><p>Java获取反射的三种方法<br><strong>1.通过new对象实现反射机制</strong> </p><p><strong>2.通过路径实现反射机制</strong> </p><p><strong>3.通过类名实现反射机制</strong></p><h4 id="装箱、拆箱"><a href="#装箱、拆箱" class="headerlink" title="装箱、拆箱"></a>装箱、拆箱</h4><p>Integer a= 127 与 Integer b = 127相等吗<br>对于对象引用类型：==比较的是对象的内存地址。<br>对于基本数据类型：==比较的是值。</p><p>如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>try和catch关键字连用，也可使用finally</p><p>throw用于主动抛出异常，th rows用于方法上抛出异常</p><h2 id="3-Java多线程"><a href="#3-Java多线程" class="headerlink" title="3.Java多线程"></a>3.Java多线程</h2><ul><li>线程就是独立的执行路径</li><li>即使进程没有创建线程，也会有多个线程，例如主线程，GC线程（垃圾回收）</li><li>main（）为主线程，为系统的入口，执行整个程序</li><li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排。</li><li>线程对同一资源访问时，会存在资源抢夺的问题，需要加入并发控制</li><li>线程会带来额外开销，例如CPU调度开销，并发控制开销</li><li>每个线程在自己的工作内存交互，内存控制不当会导致数据不一致</li></ul><p>进程与线程的区别</p><p>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>资源开销：每个进程有独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>包含关系：一个进程可以包含多个线程。</p><p>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</p><h3 id="1）多线程创建与使用"><a href="#1）多线程创建与使用" class="headerlink" title="1）多线程创建与使用"></a>1）多线程创建与使用</h3><p>可通过继承Thread类或者重写runnable接口实现，run方法写要创建多线程的代码，start（）方法启动。</p><p>继承Thread类的多线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure><p>重写runnablde</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread3 thread3 = <span class="keyword">new</span> Thread3();</span><br><span class="line"><span class="keyword">new</span> Thread(thread3).start();</span><br></pre></td></tr></table></figure><p>由于单继承局限性，推荐重写runnable创建多线程</p><p>也可通过扩展callable接口（重写call方法，有返回值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">Callable1 t1 = <span class="keyword">new</span> Callable1();</span><br><span class="line"><span class="comment">//创建执行服务</span></span><br><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//多线程池</span></span><br><span class="line"><span class="comment">//提交执行</span></span><br><span class="line">Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line"><span class="comment">//获取结果</span></span><br><span class="line"><span class="keyword">boolean</span> rs1 = r1.get();<span class="comment">//需要抛出异常</span></span><br><span class="line"><span class="comment">//关闭服务</span></span><br><span class="line">ser.shutdown();</span><br></pre></td></tr></table></figure><p>线程池：executorService，线程池接口；executors，线程池工厂，用于创建并返回不同类型的线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建服务</span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(10);创建十个线程的线程池</span><br><span class="line">service.execute(Thread);//执行服务</span><br><span class="line">service.shutdown;//关闭服务</span><br></pre></td></tr></table></figure><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><p>FutureTask实现了RunnableFuture接口，同时具有Runnable、Future的能力，即既可以作为Future得到Callable的返回值，又可以作为一个Runnable。</p><img alt="img" style="zoom:67%;" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzI3ZDBlMmUzYzBkODQyYmZhMzUyNjI0OWZjMTM3NGNk?x-oss-process=image/format,png"><h3 id="2）并发问题"><a href="#2）并发问题" class="headerlink" title="2）并发问题"></a>2）并发问题</h3><p>资源争抢导致的数据不一致问题</p><h4 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h4><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p><h3 id="3）静态代理"><a href="#3）静态代理" class="headerlink" title="3）静态代理"></a>3）静态代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">婚庆公司帮助people完成结婚工作</span><br><span class="line">WeddingCompany weddingCompany = new WeddingCompany(new People());//创建代理对象和目标对象</span><br><span class="line">weddingCompany.marry(&quot;小明&quot;);//让代理对象完成目标对象的工作</span><br><span class="line">1、分为真实对象和代理对象；</span><br><span class="line">2、真实对象和代理对象都要实现同一个接口</span><br><span class="line">3、代理对象要代理真实角色</span><br><span class="line">4、代理对象的作用是 实现一些真实对象没有实现的功能（真实对象专注做自己的功能，无需关心其它</span><br></pre></td></tr></table></figure><h3 id="4）lambda表达式"><a href="#4）lambda表达式" class="headerlink" title="4）lambda表达式"></a>4）lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"实现runnab接口的函数体"</span>)).start();<span class="comment">//lambda表达式</span></span><br><span class="line">()表示参数</span><br><span class="line"> 箭头后面的是函数体</span><br><span class="line">    即</span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"实现runnab接口的函数体"</span>);</span><br><span class="line">&#125;</span><br><span class="line">只有一行也可去掉花括号</span><br></pre></td></tr></table></figure><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>任何接口，如果只包含一个抽象方法，那就是函数式接口。对于函数式接口，就可以通过lambda表达式来创建该接口的对象</p><h3 id="5）线程"><a href="#5）线程" class="headerlink" title="5）线程"></a>5）线程</h3><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>创建状态、就绪状态、运行状态、阻塞状态、死亡状态</p><p><img alt="image-20200922202326646" data-src="F:%5Cblog%5Chexo%5Csource%5Cassets%5Cimage-20200922202326646.png"></p><h4 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h4><h5 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h5><p>jdk的方法如stop、destroy已经过时不推荐使用，建议使用标志位，打到某个条件后让线程自己停下来</p><p>如果想要线程强制停止，推荐使用外部标志位写一个stop方法强制停止</p><p>推荐让线程自然停止</p><h5 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h5><p>sleep(时间)指定当前线程的阻塞毫秒数</p><p>sleep存在异常InterruptedException</p><p>sleep时间到达后线程进行就绪状态</p><p>sleep可以模拟网络延时，计时等</p><p>sleep不会释放锁</p><h5 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h5><p>礼让线程，让当前正在执行的线程暂停，但不阻塞</p><p>让线程从运行状态变成就绪状态</p><p>让cpu重新调度</p><h5 id="join（线程插队）"><a href="#join（线程插队）" class="headerlink" title="join（线程插队）"></a>join（线程插队）</h5><p>join强制执行当前线程，待此线程执行完毕后，再执行其他线程，其他线程堵塞</p><p>尽量少使用，会让线程堵塞</p><h5 id="线程观测状态"><a href="#线程观测状态" class="headerlink" title="线程观测状态"></a>线程观测状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.State state = thread.getState();</span><br><span class="line">System.out.println(state);</span><br></pre></td></tr></table></figure><p>有 new状态、runnable（运行）状态、BLOCKED状态、TERMINATED（死亡）状态TIMED_WAITING（就绪状态）</p><h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyPriority(),<span class="string">"t1"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.setPriority(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>通过设置线程优先级来使线程先运行或者后运行，优先级高的先运行，低的后运行</p><p>默认优先级是5，范围是1-10，超过范围会报错</p><h5 id="守护（daemon）线程"><a href="#守护（daemon）线程" class="headerlink" title="守护（daemon）线程"></a>守护（daemon）线程</h5><p>线程分为用户线程和守护线程</p><p>虚拟机必须确保用户线程执行完毕</p><p>虚拟机不必等待守护线程执行完毕</p><p>守护线程如GC（垃圾回收线程），后台记录日志，垃圾回收等</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h4 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h4><p>线程不同步导致数据安全问题</p><p>保证线程安全：队列+锁，在访问数据时，加入锁机制synchronize（会影响效率）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">同步块 synchronized(obj)&#123;&#125;</span><br><span class="line">obj称为同步监视器</span><br><span class="line">obj可以是任何对象，但是推荐使用共享资源作为同步监视器</span><br><span class="line">同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this,就是这个对象本身，或者是class（反射）</span><br><span class="line">同步监视器执行过程</span><br><span class="line">1、第一个线程访问，锁定同步监视器，执行其中代码</span><br><span class="line">2、第二个线程访问，发现同步监视器被锁定，无法访问</span><br><span class="line">3、第一个线程访问完毕，锁解开，第二个线程访问</span><br></pre></td></tr></table></figure><p>ArrayList是线程不安全的</p><p>copyonwriteArrayList是线程安全的</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>多个线程互相抱着对方所需的资源，然后形成僵持，谁也执行不了</p><p>死锁的四个形成必要条件：</p><p>1、资源互斥，所访问的资源的互斥的，不能同时访问</p><p>2、请求与保持，一个线程请求资源时，对所拥有的资源保持不放</p><p>3、不可抢占，所拥有的资源不能被其它线程抢占</p><p>4、循环等待，若干线程形成互相等待的关系。</p><h4 id="lock锁"><a href="#lock锁" class="headerlink" title="lock锁"></a>lock锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLck lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">lock.lock()</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="线程协作，生产者消费者模式"><a href="#线程协作，生产者消费者模式" class="headerlink" title="线程协作，生产者消费者模式"></a>线程协作，生产者消费者模式</h4><p>生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，形成条件</p><p>生产者 - 数据缓冲区- 消费者</p><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>wait()线程进入堵塞状态</p><p>notify()唤醒一个处于wait状态的线程</p><p>notifyall()唤醒所有</p><h4 id="并发协作模型-管程法-信号灯法"><a href="#并发协作模型-管程法-信号灯法" class="headerlink" title="并发协作模型 管程法/信号灯法"></a>并发协作模型 管程法/信号灯法</h4><p>管程法：利用一个数据缓冲区存储生产者消费的商品，生产者生产商品直到缓冲区满，消费者消费商品直到没有。</p><p>信号灯法：设立标志位标志是否有产品。</p><h2 id="4-Java-IO流"><a href="#4-Java-IO流" class="headerlink" title="4.Java IO流"></a>4.Java IO流</h2><p>什么是流？ 就是进程在内存与存储设备中交换数据的通道。</p><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p><h3 id="流的分类："><a href="#流的分类：" class="headerlink" title="流的分类："></a>流的分类：</h3><p>按流向分：输入流、输出流</p><p>按传输单位分：字节流（可读取所有数据）、字符流（可读取文本数据）    </p><p>按功能分：节点流（具有数据传输数据的功能）、过滤流（在节点流的基础上增强功能)</p><p><img alt="img" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9teS1ibG9nLXRvLXVzZS5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vMjAxOS02L0lPLSVFNiU5MyU4RCVFNCVCRCU5QyVFNiU5NiVCOSVFNSVCQyU4RiVFNSU4OCU4NiVFNyVCMSVCQi5wbmc?x-oss-process=image/format,png"></p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">InputStream、OutputStream</span><br><span class="line">FileInputStream、FileOutputStream</span><br><span class="line">字节输入流</span><br><span class="line">file.open();</span><br><span class="line">file.read();</span><br><span class="line">file.close();</span><br><span class="line">字节输出流</span><br><span class="line">FileOutputStream outp = new FileOutputStream(&quot;C:\\Users\\123456\\Desktop\\Java知识总结\\test.txt&quot;);</span><br><span class="line">        outp.write(97);</span><br><span class="line">        outp.write(&apos;a&apos;);</span><br><span class="line">        outp.write(bytes);</span><br><span class="line">        outp.close();</span><br><span class="line">缓冲流 需要先给予filestream，即过滤流需要传递节点流</span><br><span class="line">BufferedInputStream </span><br><span class="line">BufferedOutputStream</span><br><span class="line">序列化和反序列化 需要先给予filestream</span><br><span class="line">ObjectOutputStream//序列化对象，将对象转化为字节流</span><br><span class="line">被序列化的对象需要实现接口Serializable(仅仅是标志接口，标志该对象可以被序列化)</span><br><span class="line"></span><br><span class="line">ObjectInputStream//反序列化</span><br></pre></td></tr></table></figure><h4 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h4><p>注意事项：</p><p>1、被序列化的对象需要实现接口Serializable(仅仅是标志接口，标志该对象可以被序列化)</p><p>2、被序列化的对象的对象属性也要实现serializable接口</p><p>3、序列化版本ID，确保序列化的类和反序列化的类是同一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本号ID serialVerID = 100L；</span><br></pre></td></tr></table></figure><p>4、使用transien修饰的属性，不能被序列化，也就是序列化该对象该属性会消失</p><p>5、静态属性不能被序列化</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>父类：Reader、Writer</p><p>子类：filereade、filewriter</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java知识总结&quot;&gt;&lt;a href=&quot;#Java知识总结&quot; class=&quot;headerlink&quot; title=&quot;Java知识总结&quot;&gt;&lt;/a&gt;Java知识总结&lt;/h1&gt;&lt;p&gt;本人学习过程中整理的大部分Java知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://shenqidaxiansheng.github.io/2020/11/14/Java%E9%9B%86%E5%90%88/"/>
    <id>http://shenqidaxiansheng.github.io/2020/11/14/Java集合/</id>
    <published>2020-11-14T02:18:11.000Z</published>
    <updated>2020-11-23T13:19:01.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><p>一些关于集合的注意点</p><a id="more"></a><h2 id="1、集合和数组的区别"><a href="#1、集合和数组的区别" class="headerlink" title="1、集合和数组的区别"></a>1、集合和数组的区别</h2><ul><li>数组的长度不可改变，集合的长度可以改变</li><li>数组可以存储基本数据类型和引用数据类型，集合只能存储引用数据类型</li><li>集合相对来说功能更加强大，通过简单的方法和属性调用即可实现各种复杂操作，提高开发效率。</li><li>数组的效率高于集合类。</li></ul><h2 id="常用的集合类有哪些？"><a href="#常用的集合类有哪些？" class="headerlink" title="常用的集合类有哪些？"></a>常用的集合类有哪些？</h2><p>Map接口和Collection接口是所有集合框架的父接口：</p><ul><li>Collection接口的子接口包括list接口和set接口还有queue接口</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间<br>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p><h2 id="Java集合的快速失败机制-“fail-fast”？"><a href="#Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="Java集合的快速失败机制 “fail-fast”？"></a>Java集合的快速失败机制 “fail-fast”？</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>解决办法：</p><p>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</p><p>使用CopyOnWriteArrayList来替换ArrayList</p><h2 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h2><p>数组转 List：使用 Arrays. asList(array) 进行转换。<br>List 转数组：使用 List 自带的 toArray() 方法。</p><h2 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h2><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><p>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。<br>性能：ArrayList 在性能方面要优于 Vector。<br>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。<br>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h2 id="为什么-ArrayList-的-elementData-加上-transient-修饰？"><a href="#为什么-ArrayList-的-elementData-加上-transient-修饰？" class="headerlink" title="为什么 ArrayList 的 elementData 加上 transient 修饰？"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h2><p>   ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。<br>       为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间</p><h2 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h2><p>相同点：都是返回第一个元素，并在队列中删除返回的对象。<br>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p><h2 id="HashMap-和-ConcurrentHashMap-的区别"><a href="#HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别"></a>HashMap 和 ConcurrentHashMap 的区别</h2><p>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）<br>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java集合&quot;&gt;&lt;a href=&quot;#Java集合&quot; class=&quot;headerlink&quot; title=&quot;Java集合&quot;&gt;&lt;/a&gt;Java集合&lt;/h1&gt;&lt;p&gt;一些关于集合的注意点&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://shenqidaxiansheng.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>腾讯一面/后台开发</title>
    <link href="http://shenqidaxiansheng.github.io/2020/03/10/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"/>
    <id>http://shenqidaxiansheng.github.io/2020/03/10/腾讯一面后台开发/</id>
    <published>2020-03-10T13:18:11.000Z</published>
    <updated>2020-11-23T13:30:59.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一面总结"><a href="#一面总结" class="headerlink" title="一面总结"></a>一面总结</h1><p>一般的一次面试，腾讯面试还挺简单的，知识点虽然底层但是大部分都会</p><a id="more"></a><h2 id="问题1：请写出冒泡排序"><a href="#问题1：请写出冒泡排序" class="headerlink" title="问题1：请写出冒泡排序"></a>问题1：请写出冒泡排序</h2><p>我用的c++写的，很快就写完了，这种热身题应该迅速写完。</p><h2 id="问题2：给定一排硬币，每个硬币面额随机，每次只能取两端的硬币，一次取一个。问给定取的次数，如何得到取得的硬币面额总和的最大值"><a href="#问题2：给定一排硬币，每个硬币面额随机，每次只能取两端的硬币，一次取一个。问给定取的次数，如何得到取得的硬币面额总和的最大值" class="headerlink" title="问题2：给定一排硬币，每个硬币面额随机，每次只能取两端的硬币，一次取一个。问给定取的次数，如何得到取得的硬币面额总和的最大值"></a>问题2：给定一排硬币，每个硬币面额随机，每次只能取两端的硬币，一次取一个。问给定取的次数，如何得到取得的硬币面额总和的最大值</h2><p>这里面试的时候我用了暴力破解，就是给出所有取法的面额，取最大值。</p><p>但是这里可以用到动态规划，如左端举例，前n个硬币面额的总和可以 这样来求：sum[i] = sum[i-1] +a[i];</p><p>右端类似，即sum[i] = sum [i+1] +a[i];。</p><h2 id="问题3：给出三次握手的过程"><a href="#问题3：给出三次握手的过程" class="headerlink" title="问题3：给出三次握手的过程"></a>问题3：给出三次握手的过程</h2><p>这个我提前看了，大概过程是：第一次握手客户端给服务器发送syn报文，告诉服务器我要向你发送数据，确认服务器是否有接受数据的能力，第二次握手是服务器给客户端发送一个应答ack报文，告诉客户端我可以接受数据，第三次握手是客户端发送给服务器一个ack报文，表示客户端发送数据、接受数据能力都正常，可以建立连接了。</p><p>具体可参考这篇掘金：</p><p><a href="https://juejin.im/post/5d9c284b518825095879e7a5" target="_blank" rel="noopener">三次握手四次挥手</a></p><h2 id="问题4-简述tcp-udp协议的区别"><a href="#问题4-简述tcp-udp协议的区别" class="headerlink" title="问题4: 简述tcp/udp协议的区别"></a>问题4: 简述tcp/udp协议的区别</h2><p>这个问题简单得很。</p><p>1、连接方面区别</p><p>TCP面向bai连du接（如打电话要先拨号建立连接）zhi。</p><p>UDP是无连dao接的，即发送数据之前不zhuan需要建立连接。</p><p>2、安全方面的区别</p><p>TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。</p><p>UDP尽最大努力交付，即不保证可靠交付。</p><h2 id="问题5：malloc申请内存的底层过程"><a href="#问题5：malloc申请内存的底层过程" class="headerlink" title="问题5：malloc申请内存的底层过程"></a>问题5：malloc申请内存的底层过程</h2><p>我当时回答的有些简单：操作系统先从空闲链表里找到符合大小的内存块，将其分配空间分配给申请的程序，返回一个void类型的指针，该空闲块剩余部分返回给空闲链表。</p><p>具体可看这个博客：<a href="https://blog.csdn.net/leex_brave/article/details/51684755" target="_blank" rel="noopener">https://blog.csdn.net/leex_brave/article/details/51684755</a></p><h2 id="问题6：硬链接软链接"><a href="#问题6：硬链接软链接" class="headerlink" title="问题6：硬链接软链接"></a>问题6：硬链接软链接</h2><p>挺简单，硬链接是基于一个引用计数器，软连接保存了完整的indox信息。</p><hr><p><strong>前面都还好，最关键是数据库这一块：</strong></p><h2 id="问题7：给定一个学生课程成绩表，该表的属性为姓名、课程、分数，如何查找一个学生的所有课程的成绩的总和？"><a href="#问题7：给定一个学生课程成绩表，该表的属性为姓名、课程、分数，如何查找一个学生的所有课程的成绩的总和？" class="headerlink" title="问题7：给定一个学生课程成绩表，该表的属性为姓名、课程、分数，如何查找一个学生的所有课程的成绩的总和？"></a>问题7：给定一个学生课程成绩表，该表的属性为姓名、课程、分数，如何查找一个学生的所有课程的成绩的总和？</h2><p>查找从这个学生的所有成绩我会（select name，score from table)，但是这个加起来emmm…（不会啊嘤嘤嘤）</p><p>然后还问了我自己创建数据库的时候索引是怎么创建的…我没用到索引啊，还在学…没答出来…</p><p>现在会了：select sum(sore) from sc where name = “该学生的名字”</p><h2 id="问题8：接下来就是聊聊自己做的项目了，不多说"><a href="#问题8：接下来就是聊聊自己做的项目了，不多说" class="headerlink" title="问题8：接下来就是聊聊自己做的项目了，不多说"></a>问题8：接下来就是聊聊自己做的项目了，不多说</h2><p>大概介绍所做项目即可。</p><h2 id="然后就是我问问题，我问了他这次对我面试的评价、意见，他说挺好的，就是基础知识（数据库。网络）这两门课还没学完，面试比较吃亏"><a href="#然后就是我问问题，我问了他这次对我面试的评价、意见，他说挺好的，就是基础知识（数据库。网络）这两门课还没学完，面试比较吃亏" class="headerlink" title="然后就是我问问题，我问了他这次对我面试的评价、意见，他说挺好的，就是基础知识（数据库。网络）这两门课还没学完，面试比较吃亏."></a>然后就是我问问题，我问了他这次对我面试的评价、意见，他说挺好的，就是基础知识（数据库。网络）这两门课还没学完，面试比较吃亏.</h2><p>还有一些问题可能遗漏了，不过没记住的问题大部分比较简单，没啥参考价值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一面总结&quot;&gt;&lt;a href=&quot;#一面总结&quot; class=&quot;headerlink&quot; title=&quot;一面总结&quot;&gt;&lt;/a&gt;一面总结&lt;/h1&gt;&lt;p&gt;一般的一次面试，腾讯面试还挺简单的，知识点虽然底层但是大部分都会&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://shenqidaxiansheng.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://shenqidaxiansheng.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第八章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/操作系统导论第八章/</id>
    <published>2019-10-14T15:18:11.000Z</published>
    <updated>2020-11-23T12:55:29.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-调度：多级反馈队列（MLFQ）"><a href="#第八章-调度：多级反馈队列（MLFQ）" class="headerlink" title="第八章 调度：多级反馈队列（MLFQ）"></a>第八章 调度：多级反馈队列（MLFQ）</h1><a id="more"></a><h2 id="8-1MLFQ：基本规则"><a href="#8-1MLFQ：基本规则" class="headerlink" title="8.1MLFQ：基本规则"></a>8.1MLFQ：基本规则</h2><p><strong>规则1：如果A的优先级 &gt; B的优先级，那么运行A</strong></p><p><strong>规则2：如果A的优先级 = B的优先级，那么轮转A和B</strong></p><h2 id="8-2改变优先级"><a href="#8-2改变优先级" class="headerlink" title="8.2改变优先级"></a>8.2改变优先级</h2><p><strong>规则3：工作进入系统时，放在最高优先级</strong></p><p><del><strong>规则4a：工作用完整个时间片后，降低其优先级</strong></del></p><p><del><strong>规则4b：如果工作在其时间切片以内主动释放CPU，则其优先级不变</strong></del></p><p><strong>规则4：一旦工作用完了在某一层的时间配额（无论中间主动放弃多少次CPU），就降低其优先级</strong></p><h2 id="8-3提升优先级"><a href="#8-3提升优先级" class="headerlink" title="8.3提升优先级"></a>8.3提升优先级</h2><p><strong>规则5：在经过一段时间S，就将系统中所有工作重新加入最高优先级队列</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第八章-调度：多级反馈队列（MLFQ）&quot;&gt;&lt;a href=&quot;#第八章-调度：多级反馈队列（MLFQ）&quot; class=&quot;headerlink&quot; title=&quot;第八章 调度：多级反馈队列（MLFQ）&quot;&gt;&lt;/a&gt;第八章 调度：多级反馈队列（MLFQ）&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第八章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第九章学习笔记</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/操作系统第九章/</id>
    <published>2019-10-14T05:01:03.000Z</published>
    <updated>2019-10-14T15:19:23.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-调度：比例份额"><a href="#第九章-调度：比例份额" class="headerlink" title="第九章 调度：比例份额"></a>第九章 调度：比例份额</h1><p><strong>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定的CPU时间，而不是优化周转时间和响应时间</strong></p><a id="more"></a><h2 id="9-1-基本概念-彩票数表示份额"><a href="#9-1-基本概念-彩票数表示份额" class="headerlink" title="9.1 基本概念: 彩票数表示份额"></a>9.1 基本概念: 彩票数表示份额</h2><p>彩票数代表了进程（或者用户或者其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><p><strong>利用随机性可以保证彩票数多的进程占用CPU时间多。</strong></p><h2 id="9-2彩票机制"><a href="#9-2彩票机制" class="headerlink" title="9.2彩票机制"></a>9.2彩票机制</h2><p><strong>规则3：工作进入系统时，放在最高优先级</strong></p><p><del><strong>规则4a：工作用完整个时间片后，降低其优先级</strong></del></p><p>彩票货币机制：一个用户可以任意的将彩票分给所拥有的进程，而操作系统会将这种彩票自动的转换成全局彩票。</p><p>彩票转让：一个进程可以临时将自己的彩票交给另一个进程。</p><p>彩票膨胀： 一个进程可以临时提升或降低自己拥有的彩票数量。</p><h2 id="9-3实现"><a href="#9-3实现" class="headerlink" title="9.3实现"></a>9.3实现</h2><p>彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p><p>用链表实现：不断遍历链表直到找到某个用户拥有目标彩票number，</p><h2 id="9-4一个例子"><a href="#9-4一个例子" class="headerlink" title="9.4一个例子"></a>9.4一个例子</h2><p>假设有两个工作，它们有相同的彩票和运行时间，在这种情况下，我们希望两个工作在大约同时完成，单由于算法的随机性，它们不会同时完成。</p><p>引入不公平指标U：将两个工作完成时刻相除即可得到U的值。</p><p>如，工作1在10完成，工作2在20完成</p><p>此时U = 10/20 = 0.5；</p><h2 id="9-5如何分配彩票"><a href="#9-5如何分配彩票" class="headerlink" title="9.5如何分配彩票"></a>9.5如何分配彩票</h2><p>彩票分配目前没有最佳答案</p><h2 id="9-6-为什么不是确定的"><a href="#9-6-为什么不是确定的" class="headerlink" title="9.6 为什么不是确定的"></a>9.6 为什么不是确定的</h2><p><strong>步长调度</strong>可以保证确定性；</p><p><strong>规则5：在经过一段时间S，就将系统中所有工作重新加入最高优先级队列</strong></p><p>但是在解决新进程加入时随机性表现更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第九章-调度：比例份额&quot;&gt;&lt;a href=&quot;#第九章-调度：比例份额&quot; class=&quot;headerlink&quot; title=&quot;第九章 调度：比例份额&quot;&gt;&lt;/a&gt;第九章 调度：比例份额&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定的CPU时间，而不是优化周转时间和响应时间&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第九章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第八章第九章作业</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E7%AC%AC%E5%85%AB%E3%80%81%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/第八、第九章作业解题报告/</id>
    <published>2019-10-14T05:01:03.000Z</published>
    <updated>2019-10-14T17:10:36.942Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="第八章作业解题报告"><a href="#第八章作业解题报告" class="headerlink" title="第八章作业解题报告"></a>第八章作业解题报告</h1><a id="more"></a><h2 id="1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。"><a href="#1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。" class="headerlink" title="1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。"></a>1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。</h2><p>解：</p><p>根据题目要求，使用命令行观察两个工作两个队列下的工作行为记录：</p><p><code>./mlfq.py -j 2 -n 2 -m 10 -M 0 -c</code></p><p>即设置工作最大长度为10，IO请求为0的两个工作，现在观察到两个工作MLFQ的执行记录如下：</p><p><img alt="1571072897249" data-src="/assets/1571072897249.png"></p><p>时间片记录如下：</p><p><img alt="1571072911400" data-src="/assets/1571072911400.png"></p><p>最终统计结果如下：</p><p><img alt="1571072930452" data-src="/assets/1571072930452.png"></p><h2 id="3-将如何配置调度程序参数，像轮转调度程序那样工作"><a href="#3-将如何配置调度程序参数，像轮转调度程序那样工作" class="headerlink" title="3.将如何配置调度程序参数，像轮转调度程序那样工作?"></a>3.将如何配置调度程序参数，像轮转调度程序那样工作?</h2><p>解：</p><p>轮转调度在第七章给出了定义，为：RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成</p><p>我们现在要实现程序像轮转调度程序那样工作，即取消所有队列，只包含一个队列，即将所有工作放在同一个队列，拥有相同优先级即可，相应命令行如下：</p><p><code>./mlfq.py -j 3 -n 1 -m 20 -q 1 -M 0 -c</code></p><p>即- j 3 表示有三个工作，n 1 表示只有一个队列，即所有程序在同一个优先级，每时间片切换一次程序，同时-m 20表示工作长度最大为20，-q 1 表示时间片为1</p><p>得到的运行结果如下：</p><p><img alt="1571072951033" data-src="/assets/1571072951033.png"></p><p>时间统计：</p><p><img alt="1571072959371" data-src="/assets/1571072959371.png"></p><p>可以看到三个工作长度为 17 8 10，轮转时间为 1 2 3，即每个时间片轮转一次程序，符合轮转调度。</p><h2 id="5-给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别-带有-B标志-，以保证一个长时间运行-并可能饥饿-的工作得到至少5-的-CPU"><a href="#5-给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别-带有-B标志-，以保证一个长时间运行-并可能饥饿-的工作得到至少5-的-CPU" class="headerlink" title="5.给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别(带有-B标志)，以保证一个长时间运行(并可能饥饿)的工作得到至少5% 的 CPU?"></a>5.给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别(带有-B标志)，以保证一个长时间运行(并可能饥饿)的工作得到至少5% 的 CPU?</h2><p>解：</p><p>该问题可以从两个层面考虑，<strong>一个是系统，一个是工作</strong>：</p><p><strong>系统方面</strong>：要保证一个长时间运行并且可能饥饿的工作能获得至少5%的CPU，由于系统带有-B标志，那么我们需要设计每隔一段时间，将所有工作推回到最高优先级，这个时间常量计算如下：<br>$$<br>S = 10/0.05 = 2000;<br>$$<br>也就是我每隔2000ms，即两秒就将所有工作放入最高优先级，即可保证长时间运行的工作获得至少5%的CPU。</p><p><strong>工作方面</strong>：最高队列的时间片长度为10ms，即如果工作在最高队列运行10秒钟，那么该工作会被降级。现在，如果我每9秒发起一次I/O请求，访问一个不相关的文件，并且不做任何操作，那么我就永远不会被降级，能最大化的保证我在CPU上的运行时间，这既是所谓的“愚弄调度程序”。</p><h1 id="第九章-作业解题报告"><a href="#第九章-作业解题报告" class="headerlink" title="第九章 作业解题报告"></a>第九章 作业解题报告</h1><h3 id="1-计算3个工作在随机种子为1-2和3时的模拟解。"><a href="#1-计算3个工作在随机种子为1-2和3时的模拟解。" class="headerlink" title="1.计算3个工作在随机种子为1.2和3时的模拟解。"></a>1.计算3个工作在随机种子为1.2和3时的模拟解。</h3><p>解：</p><p>随机种子为1 时，执行命令行：</p><p><code>./lottery.py -j 3 -s 1 -c</code></p><p>-j 3 表示三个工作。-s 1 表示种子1，得到结果如下：</p><p><img alt="1571072970872" data-src="/assets/1571072970872.png"></p><h3 id="2-现在运行两个具体的工作每个长度为10，但是一个-工作0-只有一张彩票，一个-工作1-有100张-1-10-1-10-100-。彩票数量如此不平衡时会发生什么-在工作1-完成之前，工作0是否会运行-多久-一般来说，这种彩票不平衡对彩票调度的行为有什么影响"><a href="#2-现在运行两个具体的工作每个长度为10，但是一个-工作0-只有一张彩票，一个-工作1-有100张-1-10-1-10-100-。彩票数量如此不平衡时会发生什么-在工作1-完成之前，工作0是否会运行-多久-一般来说，这种彩票不平衡对彩票调度的行为有什么影响" class="headerlink" title="2.现在运行两个具体的工作每个长度为10，但是一个(工作0)只有一张彩票，一个(工作1)有100张(-1 10 : 1 , 10 : 100)。彩票数量如此不平衡时会发生什么?在工作1 完成之前，工作0是否会运行?多久?一般来说，这种彩票不平衡对彩票调度的行为有什么影响?"></a>2.现在运行两个具体的工作每个长度为10，但是一个(工作0)只有一张彩票，一个(工作1)有100张(-1 10 : 1 , 10 : 100)。彩票数量如此不平衡时会发生什么?在工作1 完成之前，工作0是否会运行?多久?一般来说，这种彩票不平衡对彩票调度的行为有什么影响?</h3><p>解：</p><p>两个工作具有相同的工作时间，但是彩票数量却如此不平衡，可能会导致两个工作的运行时间有极大的差别，它们的完成时间也会差别非常大。在工作1完成之前，工作 0 有 0.09% 的运行概率。大概会运行一个长度的时间。</p><p>这种不平衡的彩票数量会使彩票调度的初始目标（确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间）发生偏离。</p><p>模拟结果：</p><p><img alt="1571072980416" data-src="/assets/1571072980416.png"></p><p><img alt="1571072991643" data-src="/assets/1571072991643.png"></p><p>可以看到工作1 在时间10完成，但是工作0在时间20才完成，两个工作运行时间相同的程序完成时间差距巨大</p><h3 id="3-如果运行两个长度为100的工作，都有100张彩票-1100-100-100-100-，调度程序有多不公平-运行一些不同的随机种子来确定-概率上的-答案。不公平性取决于项工作比另一项工作早完成多少。"><a href="#3-如果运行两个长度为100的工作，都有100张彩票-1100-100-100-100-，调度程序有多不公平-运行一些不同的随机种子来确定-概率上的-答案。不公平性取决于项工作比另一项工作早完成多少。" class="headerlink" title="3.如果运行两个长度为100的工作，都有100张彩票(-1100:100,100:100)，调度程序有多不公平?运行一些不同的随机种子来确定(概率上的)答案。不公平性取决于项工作比另一项工作早完成多少。"></a>3.如果运行两个长度为100的工作，都有100张彩票(-1100:100,100:100)，调度程序有多不公平?运行一些不同的随机种子来确定(概率上的)答案。不公平性取决于项工作比另一项工作早完成多少。</h3><p>如果长度相同，彩票数相同，我们期望它们的完成时间大致相同，运行不同种子得到工作时间完成表：</p><table><thead><tr><th>随机种子\完成时间</th><th>job0</th><th>job1</th><th>不公平因子U</th></tr></thead><tbody><tr><td>0</td><td>192</td><td>200</td><td>0.96</td></tr><tr><td>1</td><td>200</td><td>196</td><td>0.98</td></tr><tr><td>2</td><td>200</td><td>190</td><td>0.95</td></tr><tr><td>3</td><td>196</td><td>200</td><td>0.98</td></tr></tbody></table><p>可以看到不公平因子解决于1，已经接近公平。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第八章作业解题报告&quot;&gt;&lt;a href=&quot;#第八章作业解题报告&quot; class=&quot;headerlink&quot; title=&quot;第八章作业解题报告&quot;&gt;&lt;/a&gt;第八章作业解题报告&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="作业" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论第二章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%99%BA%E8%83%BDagent/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/12/第二章 智能agent/</id>
    <published>2019-10-12T13:53:47.366Z</published>
    <updated>2019-10-14T05:18:58.779Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="第二章-智能agent"><a href="#第二章-智能agent" class="headerlink" title="第二章 智能agent"></a>第二章 智能agent</h1><p><strong>Agent：表示能够行动的某种东西；</strong></p><a id="more"></a><h2 id="2-1Agent和环境"><a href="#2-1Agent和环境" class="headerlink" title="2.1Agent和环境"></a>2.1Agent和环境</h2><p>Agent通过传感器感知环境，并通过执行器对所处环境产生影响。</p><h2 id="2-2理性Agent"><a href="#2-2理性Agent" class="headerlink" title="2.2理性Agent"></a>2.2理性Agent</h2><p>理性A是做正确事情的Agent。</p><p>Agent的性能通过<strong>性能度量</strong>评价好坏。</p><p>性能度量：对环境状态的任何给定序列进行评估。</p><p><strong>理性Agent定义</strong>：对每一个可能的感知序列，根据已知的感知序列提供的证据和Agent具有的先验知识，理性Agent应该选择能使其性能度量最大化的行动。</p><p>理性是使期望的性能最大化，而完美是使实际的性能最大化。完美对于Agent而言是不太合理的要求。</p><p>信息收集是理性的重要部分。</p><p>如果一个Agent依赖于设计人员的先验知识而不是它自身的感知信息，这种情况我们会说Agent缺乏自主性。理性Agent应该是自主的–它应该学习，以弥补不完整的或者不正确的先验知识。</p><p>很少要求Agent一开始就完全自主，给人工智能的Agent提供一些初始知识以及学习能力是合理的。</p><p>与学习相结合使得我们可以设计在很多不同环境下都能成功的理性Agent。</p><h2 id="2-3环境的定义"><a href="#2-3环境的定义" class="headerlink" title="2.3环境的定义"></a>2.3环境的定义</h2><p>规定的性能度量、环境以及Agent的执行器和传感器，都属于任务环境。称之为PEAS描述。</p><p><strong>完全可观察的</strong>：如果Agent的传感器在每个时间点上都能获取环境的完整状态，那么我们就说任务环境是完全可观察的。如果传感器能够检测所有与行动决策相关的信息，那么该任务环境是有效完全可观察的。</p><p>与之相对的是<strong>部分可观察</strong>。</p><p><strong>单Agent与多Agent</strong></p><p>单Agent独自运行 eg.字谜游戏</p><p>多Agent同时运行 eg.国际象棋，竞争性的多agent环境</p><p>多人驾驶：避免发生冲撞使得所有Agent的性能度量最大化，所以它是一个部分合作的多Agent环境。</p><p><strong>确定的</strong>：如果环境的下一个状态完全取决于当前状态和Agent执行的动作，那么我们就说该环境是确定的；否则，它是<strong>随机的</strong>。</p><p><strong>片段式的与延续式的</strong>：在片段式的任务环境中，Agent的经历被分成了一个个原子片段。在每个片段中Agent的感知信息并完成单个行动。关键的是，下一个片段不依赖于以前的片段中采取的行动。</p><p>在延续式环境中，当前的决策会影响到所有未来的决策。</p><p><strong>静态的与动态的</strong>：如果环境在Agent计算的时候会变化，那么我们称该Agent的环境是动态的；否则环境是静态的。</p><p>动态环境会持续地要求Agent做决策；如果Agent没有做出决策，Agent则认为它决定不作任何事情。</p><p>如果环境本身不随时间变化而变化，但是Agent的性能评价随时间变化，我们称这样的决策为<strong>半动态</strong>的。</p><p><strong>离散的与连续的</strong>。环境的状态，时间的处理方式以及agent的感知信息和行动都有离散/连续之分。</p><p><strong>已知的和未知的</strong>。</p><h2 id="2-4Agent的结构"><a href="#2-4Agent的结构" class="headerlink" title="2.4Agent的结构"></a>2.4Agent的结构</h2><p><strong>Agent = 体系结构 + 程序</strong></p><p>本书中我们设计的Agent程序都具有相同的框架：输入为从传感器得到的当前感知信息，返回的是执行器的行动抉择。</p><p>Agent的表驱动方法：</p><p><strong>缺点</strong>：</p><p>Ø表太大</p><p>Ø创建表时间长</p><p>Ø非自主性，需人工填写</p><p>Ø即使能够学习，也需要很长的时间</p><p><strong>Agent的类型</strong>：</p><p>Ø简单反射agent</p><p>Ø基于模型的反射agent</p><p>Ø基于目标的agent</p><p>Ø基于效用的agent</p><p><strong>简单反射agent</strong>：</p><img alt="1570863454367" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863454367.png"><p><strong>基于模型的agent：</strong></p><img alt="1570863522199" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863522199.png"><p><strong>基于目标的agent</strong></p><p>除了根据感知信息之外，还要根据目标信息来选择行动</p><p>效率比较低，需要推理</p><p>搜索和规划算法</p><img alt="1570863592280" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863592280.png"><p><strong>基于效用（utility）的agent</strong>：</p><p>当达到目标的行为有很多种的时候，需要考虑效率</p><p>环境是部分可观察的和随机的，不确定下的决策过程可以通过基于效用的agent来实现。</p><p>效用的作用：</p><p>Ø多目标相冲突时，折中方案</p><p>Ø多目标在不确定环境中</p><p>Ø一个目标有多种行为可以达到时</p><img alt="1570863740202" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863740202.png"><p><strong>学习Agent</strong></p><p>四个部件：</p><p>Ø性能元件：相当于整个agent</p><p>Ø评判元件：反映性能元件做得如何</p><p>Ø学习元件：负责改进提高</p><p>Ø问题产生器：提出一些新的有建设性的探索尝试</p><img alt="1570863807685" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863807685.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Agent是可以感知环境并在环境中行动的事物。Agent函数指定Agent响应任何感知序列所采取的行动</li><li>性能度量评价Agent在环境中的行为表现。给定Agent感知序列，理性Agent行动追求性能度量预期值最大化。</li><li>任务环境的规范包括性能度量、外部环境、执行器和传感器。设计Agent时，第一步总是把任务空间定义得尽可能完全。</li><li>任务环境从不同的维度看有很多变化、它们可能是完全或部分可观察的，单Agent或多Agent的，确定的或随机的，片段式的或延续式的，静态的或动态的，离散的或连续的，已知的或未知的。</li><li>Agent程序是Agent函数的实现。</li><li>简单反射Agent直接对感知信息作出反应，基于模型的反射Agent保持内部状态，追踪记录当前感知信息中反映不出来的世界各个方面。基于目标的Agent的行动是为了达到目标，基于效用的Agent试图最大化它期望的“快乐”</li><li>所有Agent都可以通过学习来改进它们的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;第二章-智能agent&quot;&gt;&lt;a href=&quot;#第二章-智能agent&quot; class=&quot;headerlink&quot; title=&quot;第二章 智能agent&quot;&gt;&lt;/a&gt;第二章 智能agent&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Agent：表示能够行动的某种东西；&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第二章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论第一次作业</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/12/%E4%BD%9C%E4%B8%9A%E4%B8%80%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/12/作业一解题报告/</id>
    <published>2019-10-12T13:53:47.330Z</published>
    <updated>2019-10-14T05:22:12.942Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="作业一解题报告"><a href="#作业一解题报告" class="headerlink" title="作业一解题报告"></a>作业一解题报告</h1><a id="more"></a><p><strong>1.考虑一个实时的在线电话翻译系统，该系统实现英语与日语之间的实时在线翻译，讨论该系统的性能度量，环境，执行器，感知器，并对该环境的属性进行分析。</strong></p><p>​    解答：</p><ul><li><p>性能度量：翻译的正确性，保证翻译不能偏离原来的语义；翻译的速度，不能有过高的延迟，否则就不能完成 “实时”；</p></li><li><p>环境：首先是声源噪音，除了有意义的对话外，麦克风还可能接收到各种各样的噪音，例如风声等；然后是电话线路，声音在传播过程中的线路；除此之外，翻译系统还需要考虑每个人不同的口音，每个人说的话波长频率都不一样。</p></li><li><p>执行器：喇叭，音响等发声器</p></li><li><p>感知器：麦克风，接收声音。</p></li><li><p>环境的属性：</p><p>1、完全可观察的：可以获取声音的全部属性。</p><p>2、单Agent，显然只有它本身一个Agent。</p><p>3、随机的，你无法根据自身的状态决定需要翻译的对象下一句话说什么。</p><p>4、现在的翻译系统大多会联系上下文，所以是连续式的，当然，如果本翻译系统只是一个单词翻译一个单词，那么就是片段式的。</p><p>5、动态的，声音来源可能不断的输入以致Agent需要不断地进行翻译，而且根据下一个单词或句子的不同本次翻译的单词意思可能也不一样。</p><p>6、连续的，翻译过程是一个连续的过程。</p><p>7、已知的，语法规则是设计人员知道的。</p></li></ul><p><strong>2.考虑一个医疗诊断系统的agent，讨论该agent最合适的种类(简单agent,基于模型的agent,基于目标的agent和基于效用的agent)并解释你的结论。</strong></p><p>解答：</p><p>基于效用的agent；原因：疾病诊断需要综合很多因素，同一种表现可能是由不同的疾病引起的（例如胃痛可能是肠胃炎、胃穿孔引起，更糟糕的是胃癌引起），所以需要综合不同的因素做出最可能患的疾病的决策，这和效用模型类似——做出使其期望效用最大化的选择，即最可能的选择。</p><p><strong>3.先建立一个完整的搜索树，起点是S,终点是G,如下图,节点旁的数字表示到达目标状态的距离，然后用以下方法表示如何进行搜索，并分析几种算法的完备性、最优性、以及时间复杂度和空间复杂度。</strong></p><p>解答：</p><p>搜索树：</p><img alt="1570882949017" style="zoom:67%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570882949017.png"><p>深度优先：</p><img alt="1570882988966" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570882988966.png"><p>从开始节点s，不断深度搜索，可以一直搜索直到到达终点G。</p><p>完备性：在有限空间是完备的，因为它至多扩展所有节点，在无限状态空间中，遭遇了无限又无法到达的节点，则不完备。</p><p>最优性：不是最优的，返回的是最先找到的解，而不是最优解。</p><p>时间复杂度：考虑空间分子为b最大深度为m，那么时间复杂度为 :<br>$$<br>O(b^m)<br>$$<br>空间复杂度：<br>$$<br>O(bm)<br>$$</p><p>宽度优先：</p><img alt="1570883063466" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883063466.png"><p>完备性：是完备的，如果目标节点存在于一个有限深度d，那么宽度优先搜索能找到它。</p><p>最优性：不是最优的，返回的是最浅的解，而不是最优解。</p><p>时间复杂度：假设每个状态有b个后继，d为深度 :<br>$$<br>O(b^d)<br>$$<br>空间复杂度：<br>$$<br>O(b^d)<br>$$<br>爬山法：</p><img alt="1570883096745" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883096745.png"><p>从s节点开始，每次寻找代价最小的，直到达到最终节点G</p><p>完备性：不是完备的，找到的是局部最优，不一定是全局最优。</p><p>最优性：不一定能找到最优解。</p><p>时间复杂度：最多遍历n个节点，所以时间复杂度为<br>$$<br>O(n)<br>$$<br>空间复杂度：同时间复杂度，为<br>$$<br>O(n)<br>$$<br>最佳优先：</p><img alt="1570883160240" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883160240.png"><p>从s节点开始，先找节点A，此时节点A的代价为8，然后找节点B，代价为9，然后找节点D，代价为23，,然后扩展节点G得到结果。</p><p>完备性：不是完备的，<strong>可能会陷入死循环</strong>。</p><p>最优性：不一定能找到最优解。</p><p>时间复杂度：设搜索空间的最大深度是m，一个结点会有b个后继结点，最坏情况下，时间复杂度为<br>$$<br>O(b^m)<br>$$<br>空间复杂度：同时间复杂度，为<br>$$<br>O(b^m)<br>$$<br><strong>4.图二是一棵部分展开的搜索树，其中树的边记录了对应的单步代价，叶子节点标注了到达目标结点的启发式函数的代价值，假定当前状态位于结点A。</strong></p><p><strong>a)       用下列的搜索方法来计算下一步需要展开的叶子节点。注意必须要有完整的计算过程，同时必须对扩展该叶子节点之前的节点顺序进行 记录：</strong></p><ol><li><p><strong>贪婪最佳优先搜索</strong></p></li><li><p><strong>一致代价搜索</strong></p></li><li><p><strong>A*树搜索</strong></p></li></ol><p><strong>(b)  讨论以上三种算法的完备性和最优性。</strong></p><img alt="1570887643455" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570887643455.png"><p>​                                                                        图二</p><p>a)    1、贪婪最佳优先搜索，即试图扩展离目标节点最近的节点，因此只采用启发式，即</p><p>  f(n) = h(n)  </p><p>由图可知<br>$$<br>h(c) = 5, h(D) = 10,h(E) = 10,h(F) = 12, h(G)=8,h(H)=10<br>$$<br>注意到h(B) 没有给出，因此，如果h(B)&gt;5,首先访问叶子结点C,如果h(B)&lt;=5,首先访问B,再访问C.</p><p>2、一致代价搜索，即按照g（n）升序搜索，由图可知：<br>$$<br>g(B)= 3,g(C) = 19, g(D) = 5, g(E) = 6, g(F) = 8, g(G) = 9, g(H) = 9<br>$$<br>所以搜索顺序为BDEFGHC，下一步搜索的节点为B</p><p>3、A*树搜索，即缩小总评估代价，由于<br>$$<br>f(n) = g(n) + h(n)<br>$$<br>可知各个节点f(n)为<br>$$<br>f(B)=?,  f(C) = 24, f(D) = 18, f(E) = 16, f(F) = 20, f(G) = 17, f(H) = 19<br>$$<br>故如果h(B)&gt;15,首先访问D如果h(B)&lt;=15,首先访问B,再访问E,G,D,H,F,C</p><p>b)</p><p>贪婪最佳优先搜索：</p><p>完备性：即使是有限状态空间，搜索路径遇到环也会失败，或者是无限状态下，此时也是不完备的</p><p>最优性：它的搜索代价是最小的，但是却不是最优的。</p><p>一致代价搜索：</p><p>完备性：如果存在零代价，则会陷入死循环，此时不是完备的，其它情况都是完备的</p><p>最优性：一定能找到最优解</p><p>A*树搜索</p><p>完备性：是完备的，能找到解</p><p>最优性：如果h(n)启发式函数是可采纳的，那么A* 的树搜索是最优的，如果h(n)是一致的，那么图搜索的A*算法是最优的</p><p><strong>5.给定一个启发式函数满足h(G)=0,其中G是目标状态，证明如果h是一致的，那么它是可采纳的。</strong></p><p>解答：</p><p>假设n为任意一个状态，G是任意一个目标状态，1,2,3..，m为从状态n到达G的一条最优路径，<br>$$<br>已知评估代价为f(n) = g(n)+ h(n)<br>$$</p><p>$$<br>真实代价f’(n)=g(n)+c(n,a1,n1)+c(n1,a2,n2)+….c(nm,am+1,G)<br>$$</p><p>$$<br>那么：f(n)=g(n)+h(n)&lt;=g(n)+c(n,a1,n1)+h(n1)<br>$$</p><p>$$<br>&lt;=g(n)+c(n,a1,n1)+c(n1,a2,n2)+h(n2)<br>$$</p><p>$$<br>&lt;=…..&lt;=g(n)+c(n,a1,n1)+c(n1,a2,n2)+….c(nm,am+1,G)+h(G)<br>$$</p><p>$$<br>=f’(n）<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;作业一解题报告&quot;&gt;&lt;a href=&quot;#作业一解题报告&quot; class=&quot;headerlink&quot; title=&quot;作业一解题报告&quot;&gt;&lt;/a&gt;作业一解题报告&lt;/h1&gt;
    
    </summary>
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="作业" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第七章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操作系统导论第七章/</id>
    <published>2019-10-08T09:43:11.612Z</published>
    <updated>2019-10-14T15:18:40.816Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第七章：进程调度"><a href="#操作系统导论第七章：进程调度" class="headerlink" title="操作系统导论第七章：进程调度"></a>操作系统导论第七章：进程调度</h1><p>操作系统该如何决定切换进程？如何运行进程使得效率最大化？</p><a id="more"></a><h2 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h2><p>1、周转时间<br>$T_{周转时间}=T_{完成时间}-T_{到达时间}$<br>2、响应时间<br>$T_{响应时间}=T_{第一次执行时间}-T_{到达时间}$</p><h2 id="先进先出（FIFO）调度原则"><a href="#先进先出（FIFO）调度原则" class="headerlink" title="先进先出（FIFO）调度原则"></a>先进先出（FIFO）调度原则</h2><p>假设3个工作 a，b，c工作长度为10s，它们大致在相同时间到达（$T_{到达}=0$)但是a比b稍微早一点点，b比c稍微早一点点。<br>那么平均周转时间是$T=(10+20+30)/3 = 20$<br>但是假设a = 100，b和c仍然是10<br>那么平均周转时间是$T=(100+110+120)/3 = 110$<br>可以看出，FIFO调度策略对周转时间不友好</p><h2 id="最短任务优先-（SJF）"><a href="#最短任务优先-（SJF）" class="headerlink" title="最短任务优先 （SJF）"></a>最短任务优先 （SJF）</h2><p>仍然考虑a = 100，b和c仍然是10的情况<br>平均周转时间是$T=(10+20+120)/3 = 50$<br>但是，如果abc不是同时到达，而是a先到达，那么平均周转时间和FIFO一样了。</p><h2 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h2><p>为了解决这个问题，我们让最短完成时间的任务先运行，那么即使是a先到达，但在bc到达时切换到bc进程运行，这样平均周转时间就又恢复成50s。</p><h2 id="轮转（RR）调度策略"><a href="#轮转（RR）调度策略" class="headerlink" title="轮转（RR）调度策略"></a>轮转（RR）调度策略</h2><p>前面都只是针对周转时间，但是响应时间如何（在一个好的交互系统，响应时间尤为重要，用户不会愿意等它前面的进程完成后才响应当前进行的操作）<br>这就引出了一种新的调度算法：轮转<br>RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成。</p><h2 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h2><p>当进程请求I/O时，操作系统可以切换下一个进程，等进程I/O请求完成后，再切换回来，提升CPU使用效率。</p><h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><p>1、</p><p>SJF为最短任务优先原则，现在用这个策略调度长度为200的3个作业，由于作业长度一样（都为200），则假设a、b、b先后运行，那么各个响应周转时间应该如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173735334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>-c测试：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173802907.png"></p><p>与计算相符。</p><p>FIFO为先进先出策略，即先到的任务先运行，由于三个作业长度都为200，所以结果应该与SJF策略相同，-c测试：</p><p>一样。</p><p>2、</p><p>采用SJF策略调度，那么先后运行的任务是 100 200 300</p><p>假设它们为a b c 任务，那么各个时间计算如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173857430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173920851.png"><br>采用FIFO策略，假设任务到达的先后顺序为 100 200 300</p><p>那么需要的各个时间应该与SJF调度是一样的。如果是 300 200 100，那么需要的时间不同：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173932306.png"></p><p>3、</p><p>RR调度程序，即轮转调度，在一个时间片（time<br>slice，有时称为调度量子）内运行一个工作，然后切换到队列的下一个任务，即每个时间片切换一个不同的程序，反复执行，直到所有任务完成。时间片必须是时钟中断周期的倍数，因为它依靠时钟周期中断实现。</p><p>现在时间片为1，即每隔一秒切换一次，各个时间应该如下：（仍然假设各个任务为 a b c）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>4、<br>1、在相同时间到达，运行相同时间的任务</p><p>2、在不同时间到达，但是任务的到达顺序是运行时间由短到长。</p><p>这两种类型的工作负载的周转时间都相同。</p><p>5、</p><p>每个工作的工作负载和量子长度相同时，SJF与RR提供相同的响应时间。</p><p>6、</p><p>SJF的其它工作（除了第一份工作，因为它是第一个运行，响应时间为0）响应时间会随着工作长度的增加而增加。</p><p>现在我假设三个工作（依然是 a b c），我将从100 200 300 开始不断的增加长度，使用模拟程序查看平均响应时间，得到结果如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174120557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"> </p><p>可以看到，平均响应时间确实是随着工作长度的增加而增加。</p><p>7、</p><p>显然，随着量子长度的增加，RR的响应时间也会随着增加。</p><p>最坏情况：首先我们假设这N个工作的到达顺序为从最长的到最短的，假设它们的序号为1,2，3…N，量子长度为S</p><p>且最长的工作（序号为1）的工作长度为小于等于量子长度即</p><p>1&lt;=S;</p><p>那么，这组工作的响应时间即是前N-1个工作长度的总合，即为</p><p>1+2+3+4+…+（N-1）</p><p>（注意这里的数字1,2,3,4表示的是工作的序号，不是工作长度，它们的工作长度顺序是1&gt;2&gt;3&gt;4..）</p><p>即最坏情况下的响应时间是<strong>除了长度最短的工作</strong>的<strong>所有工作长度的总合</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;a href=&quot;#操作系统导论第七章：进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;/a&gt;操作系统导论第七章：进程调度&lt;/h1&gt;&lt;p&gt;操作系统该如何决定切换进程？如何运行进程使得效率最大化？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第七章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第六章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操行系统导论第六章/</id>
    <published>2019-10-08T08:55:42.863Z</published>
    <updated>2019-10-08T08:55:42.864Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第六章：受限直接运行"><a href="#操作系统导论第六章：受限直接运行" class="headerlink" title="操作系统导论第六章：受限直接运行"></a>操作系统导论第六章：受限直接运行</h1><p>第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。<br>然而这样带来了一些问题：<br>1、如何在不增加系统开销的情况下实现虚拟化？<br>2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）</p><p>操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。</p><a id="more"></a><h2 id="基本技巧-受限直接运行"><a href="#基本技巧-受限直接运行" class="headerlink" title="基本技巧:受限直接运行"></a>基本技巧:受限直接运行</h2><p>为了使程序尽可能快地运行，只需直接在CPU上运行程序即可，但是为了解决上面提到的问题，我们必须给予运行程序一些限制。</p><h2 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h2><p>当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中，找到入口点（main（）），跳转到哪里，并开始运行用户的代码。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>为了限制进程的运行，硬件 通过提供不同的执行模式来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源（操作系统就处于这一模式下）。<br>但是在用户模式下，给予一些方式使得程序能够短暂进入内核模式是有必要的。因为大部分的应用程序都需要进行I/O和其他相关操作。<br>现代硬件提供了用户程序执行系统调用的能力。<br>要执行系统调用，程序必须执行特殊的陷阱指令。该指令同时跳入内核并将特权级别提升到内核模式。完成所需的工作后，操作系统调用一个特殊的从陷阱返回的指令，应用程序回到用户模式。</p><h2 id="在进程中切换"><a href="#在进程中切换" class="headerlink" title="在进程中切换"></a>在进程中切换</h2><p>当一个进程在CPU上运行时，就意味着操作系统没有运行，那么操行系统应该如何决定停止一个进程并开始另一个进程？显然，一个没有运行的操作系统是无法执行任何操作的。<br>那么，操作系统应该如何在进程运行时重获CPU的控制权？<br>协作方式：等待系统调用。<br>过去系统采用这种等待进程进行系统调用的方式，当进程进行系统调用时，将控制权交给操作系统。<br>但是，如果一个进程永远不进行系统调用，也不出错，那么这种方式就无法解决问题了。<br>为此操作系统采用时钟中断来重获控制权。</p><h2 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h2><p>如果操作系统决定切换进程，那么操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核指针，然后恢复即将切换的程序的上下文，并切换栈。<br>通过切换栈，内核在进入切换代码调用时，是被中断进程的上下文，在返回时，是另一个进程的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;a href=&quot;#操作系统导论第六章：受限直接运行&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;/a&gt;操作系统导论第六章：受限直接运行&lt;/h1&gt;&lt;p&gt;第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。&lt;br&gt;然而这样带来了一些问题：&lt;br&gt;1、如何在不增加系统开销的情况下实现虚拟化？&lt;br&gt;2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）&lt;/p&gt;
&lt;p&gt;操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第六章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第五章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/25/操作系统导论第五章/</id>
    <published>2019-09-24T17:18:23.188Z</published>
    <updated>2019-09-24T17:20:08.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第五章：进程API"><a href="#操作系统导论第五章：进程API" class="headerlink" title="操作系统导论第五章：进程API"></a>操作系统导论第五章：进程API</h1><a id="more"></a><h2 id="UNIX的系统调用"><a href="#UNIX的系统调用" class="headerlink" title="UNIX的系统调用"></a>UNIX的系统调用</h2><p>UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。</p><p>父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。</p><h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><strong><em>先贴一段简单的调用fork函数的代码</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello,world.\n&quot;);</span><br><span class="line">int x = 100;</span><br><span class="line">int rc = fork();</span><br><span class="line">if(rc&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;fork failed\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">else if(rc==0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello,I am child\n&quot;);</span><br><span class="line">printf(&quot;x=%d\n&quot;,x+7);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;hello,I am parent\n&quot;);</span><br><span class="line">printf(&quot;x=%d\n&quot;,x+8);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>运行结果是：</p><p><img alt data-src="https://img-blog.csdnimg.cn/20190925010803571.png"></p><p>可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。<br>说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。<br>注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。</p><h2 id="exec函数调用"><a href="#exec函数调用" class="headerlink" title="exec函数调用"></a>exec函数调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int rc = fork();</span><br><span class="line">if(rc&lt;0)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr,&quot;fork failed\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">else if(rc==0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;child\n&quot;);</span><br><span class="line">execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);</span><br><span class="line">execle(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL,NULL);</span><br><span class="line">execlp(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;,NULL);</span><br><span class="line"></span><br><span class="line">char *m[] = &#123;&quot;ls&quot;,&quot;-l&quot;,NULL&#125;;</span><br><span class="line">execve(&quot;/bin/ls&quot;,m,NULL);</span><br><span class="line">execv(&quot;/bin/ls&quot;,m);</span><br><span class="line">execvp(&quot;/bin/ls&quot;,m);</span><br><span class="line"></span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;parent\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec（）函数族有六个变体<br>根据参数类型，大体可以分为两类：<br>•    以 list 可变参数传参<br>•    execl<br>•    execlp<br>•    execle<br>•    以 vector 数组传参<br>•    execv<br>•    execvp<br>•    execve<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190925011659188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>各个函数变体参数如上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;a href=&quot;#操作系统导论第五章：进程API&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;/a&gt;操作系统导论第五章：进程API&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第五章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第四章作业解题报告</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/24/操作系统导论第四章模拟作业解题报告/</id>
    <published>2019-09-24T10:11:38.061Z</published>
    <updated>2019-09-24T16:45:32.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第四章：进程"><a href="#操作系统导论第四章：进程" class="headerlink" title="操作系统导论第四章：进程"></a>操作系统导论第四章：进程</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程就是运行中的程序</p><h2 id="一台机器上如何同时运行多个程序？"><a href="#一台机器上如何同时运行多个程序？" class="headerlink" title="一台机器上如何同时运行多个程序？"></a>一台机器上如何同时运行多个程序？</h2><p><strong><em>这里的关键问题是：如何提供有许多CPU的假象？</em></strong></p><p>我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？</p><p>操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。</p><h1 id="模拟作业"><a href="#模拟作业" class="headerlink" title="模拟作业"></a>模拟作业</h1><p>操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载：</p><p><a href="http://http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html" target="_blank" rel="noopener">操作系统导论homework</a>，加载时间可能会常一些，正常等待即可。</p><p>然后从该网站上下载本章需要的作业程序：<em>process-run.py</em>，</p><p>解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。</p><p>博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。</p><p>下面是本章作业1-5题的个人解答，只供参考：</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>1、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180655603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>-c检查：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019092418071355.png"></p><p>和预期相符。</p><p>2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1.</p><p>所以完成这两个进程需要时间为 10；</p><p>检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180729945.png"></p><p>预期相符。</p><p>3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1.</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180754924.png"></p><p>从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。</p><p>4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180820315.png"></p><p>与预期相符</p><p>5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180834685.png"></p><p>与预期相符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第四章：进程&quot;&gt;&lt;a href=&quot;#操作系统导论第四章：进程&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第四章：进程&quot;&gt;&lt;/a&gt;操作系统导论第四章：进程&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="第四章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/15/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/15/新文档/</id>
    <published>2019-08-15T13:42:39.129Z</published>
    <updated>2019-08-15T13:42:39.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的foreach语法"><a href="#java中的foreach语法" class="headerlink" title="java中的foreach语法"></a>java中的foreach语法</h1><p>形式：for(x:a)<br>例如：<br>   <code>int  a[10], x;</code><br>    <code>for(x:a)</code><br>表示将a数组中的每个元素按下标索引的顺序赋值给x；</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的foreach语法&quot;&gt;&lt;a href=&quot;#java中的foreach语法&quot; class=&quot;headerlink&quot; title=&quot;java中的foreach语法&quot;&gt;&lt;/a&gt;java中的foreach语法&lt;/h1&gt;&lt;p&gt;形式：for(x:a)&lt;br&gt;例如：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/02/index/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/02/index/</id>
    <published>2019-08-01T19:34:51.000Z</published>
    <updated>2020-11-23T12:55:02.615Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+github 搭建个人博客</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hexo+github 搭建个人博客/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-08-01T19:20:39.275Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://shenqidaxiansheng.github.io/">博主的博客</a><br>觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号</p><ol><li>注册github账号，你可以去这里注册：<a href="https://github.com/" target="_blank" rel="noopener">github登陆界面</a>，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到</li><li>注册号github账号后，就可以去新建一个仓库，：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802012834196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>如图点击new按钮，新建一个仓库，到了这个页面：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802013358361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io<br>新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。</li><li>下载git，可以去这里下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git下载地址</a>，点击download就可以下载了，下载完成安装就可以了</li><li>然后我们再安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2>前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014643948.png"><br>创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014955292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>打开git bash ，不出意外你将得到这个界面：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802031455315.jpg"><br>这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成<br>输入以下代码安装hexo：<br><code>npm install hexo -g</code><br>安装完成后，输入<br><code>hexo init</code><br>完成初始化<br>##关键一步：将hexo和GitHub上创建的仓库联系起来<br>网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦<br>首先，我们先输入以下命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br></pre></td></tr></table></figure><p>如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥<br>输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\id_rsa.pub，例如博主的这个文件就在这：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802020710806.png"><br>用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：<br>点击 new ssh key，是是啊撒大声地大大大是是是<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802021007911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。<br>有了ssh秘钥就可以把本地文件和github上的仓库联系起来<br>继续在gitbash上执行如下命令：<br>    <code>git config --global user.name &quot;username&quot;// 你的github用户名，非昵称</code><br>    <code>git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code><br>这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。</p><p>##将本地博客上传到github上<br>输入以下命令：<br>    <code>hexo g</code><br>    <code>hexo s</code><br>然后在游览器上打开网址：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。<br>然后输入以下命令：<br>    <code>hexo clean</code><br>    <code>hexo g</code><br>    <code>hexo d</code><br>hexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。<br>输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）<br>利用hexo大家博客完成</p><p>##写博客<br>博客搭好后，我们如何写博客并且上传到自己的博客页面？<br>先按照这个路径点开这个文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802023807653.png"><br>这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，<br>执行命令：<br>    <code>hexo new page &quot;my-first-blog&quot;</code><br>就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（<a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">makedown下载地址</a>）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。<br>当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了<br>(╥╯^╰╥)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://shenqidaxiansheng.github.io/&quot;&gt;博主的博客&lt;/a&gt;&lt;br&gt;觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺&lt;/p&gt;
    
    </summary>
    
      <category term="搭建个人博客及美化" scheme="http://shenqidaxiansheng.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96/"/>
    
    
      <category term="hexo" scheme="http://shenqidaxiansheng.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://shenqidaxiansheng.github.io/tags/github/"/>
    
      <category term="个人博客" scheme="http://shenqidaxiansheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>四六级词汇学习笔记</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/四六级词汇/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-07-30T12:39:08.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四六级词汇学习笔记"><a href="#四六级词汇学习笔记" class="headerlink" title="四六级词汇学习笔记"></a>四六级词汇学习笔记</h2><a id="more"></a><p>英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。</p><h2 id="前缀示例："><a href="#前缀示例：" class="headerlink" title="前缀示例："></a>前缀示例：</h2><p>deriver from –源自于<br>deviate from –偏离(deviate脱离）<br>前缀：de -&gt; down(下降)<br>derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于<br>decrease(减少)<br>decline(n.下降，vt 婉拒）<br>(同义词 refus ，reject)<br>前缀re 表示again再一次 或者 back返回<br>retell 再讲一遍<br>return 返回，回报<br>词根fuse = flow 表示流动<br>refuse 表示流回去（拒绝）<br>ject-词根-扔<br>reject 扔回去（强烈的拒绝）</p><p>steam from 也表示源自于的意思<br>steam 名词-根茎<br>originate from 源自于</p><p>discount：n.折扣，v.认为..不重要<br>前缀-dis-表示否定<br>count计算，discount即表示打折扣</p><p>account：n.账目，赊账<br>前缀-ac-强调作用<br>a+辅音<br>（aeiou五个字母为元音字母，其余为辅音字母）<br>（元音字母可以替换但是意思不变，例如：begin-began-begun<br>Man-Men）<br>count-计数，数数<br>counter ：计算器，计数器，柜台<br>作形容词还可表示相反的<br>作副词表示相反地<br>作动词表示反对<br>（OTC：over the counter）<br>counterbalance:制衡（从相反的方向平衡）</p><p>后缀er（和or相同）-表示人或者物）<br>cooker（厨具）<br>tractor（拖拉机）</p><h2 id="后缀示例："><a href="#后缀示例：" class="headerlink" title="后缀示例："></a>后缀示例：</h2><p>origin-n.起源-后缀ate<br>original-adj.原始的-后缀al</p><p>fluctuate 起伏不定<br>后缀-ate：<br>1、名词，例如：graduate毕业生，candidate候选人<br>2、动词，例如：graduate 毕业（动词）<br>3、形容词，例如：private<br>前缀：flu流动<br>fluent：流利的<br>后缀：ent=ant 表示形容词或者名词后缀<br>account，servant，<br>fluid<br>名词 液体，形容词流动的<br>反义词 solid<br>influential<br>前缀：in 表在里面<br>也可表否定，这时一般做形容词前缀</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四六级词汇学习笔记&quot;&gt;&lt;a href=&quot;#四六级词汇学习笔记&quot; class=&quot;headerlink&quot; title=&quot;四六级词汇学习笔记&quot;&gt;&lt;/a&gt;四六级词汇学习笔记&lt;/h2&gt;
    
    </summary>
    
      <category term="英语学习" scheme="http://shenqidaxiansheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="英语学习," scheme="http://shenqidaxiansheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="四六级" scheme="http://shenqidaxiansheng.github.io/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hello-world/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hello-world/</id>
    <published>2019-07-29T07:02:22.715Z</published>
    <updated>2019-07-29T08:23:27.991Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
