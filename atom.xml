<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只神奇的DXS</title>
  
  <subtitle>一名计算机学生的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenqidaxiansheng.github.io/"/>
  <updated>2019-10-14T15:15:17.329Z</updated>
  <id>http://shenqidaxiansheng.github.io/</id>
  
  <author>
    <name>Jing Hua</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统导论第八章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/操作系统导论第八章/</id>
    <published>2019-10-14T15:18:11.000Z</published>
    <updated>2019-10-14T15:15:17.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四六级词汇学习笔记"><a href="#四六级词汇学习笔记" class="headerlink" title="四六级词汇学习笔记"></a>四六级词汇学习笔记</h2><h1 id="第八章-调度：多级反馈队列（MLFQ）"><a href="#第八章-调度：多级反馈队列（MLFQ）" class="headerlink" title="第八章 调度：多级反馈队列（MLFQ）"></a>第八章 调度：多级反馈队列（MLFQ）</h1><h2 id="8-1MLFQ：基本规则"><a href="#8-1MLFQ：基本规则" class="headerlink" title="8.1MLFQ：基本规则"></a>8.1MLFQ：基本规则</h2><p><strong>规则1：如果A的优先级 &gt; B的优先级，那么运行A</strong></p><p><strong>规则2：如果A的优先级 = B的优先级，那么轮转A和B</strong></p><h2 id="8-2改变优先级"><a href="#8-2改变优先级" class="headerlink" title="8.2改变优先级"></a>8.2改变优先级</h2><p><strong>规则3：工作进入系统时，放在最高优先级</strong></p><p><del><strong>规则4a：工作用完整个时间片后，降低其优先级</strong></del></p><p><del><strong>规则4b：如果工作在其时间切片以内主动释放CPU，则其优先级不变</strong></del></p><p><strong>规则4：一旦工作用完了在某一层的时间配额（无论中间主动放弃多少次CPU），就降低其优先级</strong></p><h2 id="8-3提升优先级"><a href="#8-3提升优先级" class="headerlink" title="8.3提升优先级"></a>8.3提升优先级</h2><p><strong>规则5：在经过一段时间S，就将系统中所有工作重新加入最高优先级队列</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四六级词汇学习笔记&quot;&gt;&lt;a href=&quot;#四六级词汇学习笔记&quot; class=&quot;headerlink&quot; title=&quot;四六级词汇学习笔记&quot;&gt;&lt;/a&gt;四六级词汇学习笔记&lt;/h2&gt;&lt;h1 id=&quot;第八章-调度：多级反馈队列（MLFQ）&quot;&gt;&lt;a href=&quot;#第八章-调度
      
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第八章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>“操作系统导论第八章第九章作业</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E7%AC%AC%E5%85%AB%E3%80%81%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/第八、第九章作业解题报告/</id>
    <published>2019-10-14T05:01:03.000Z</published>
    <updated>2019-10-14T15:16:32.269Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>学号：201708010720                 姓名：钟京华            班级： 计科1707</em></strong></p><hr><hr><h1 id="第八章作业解题报告"><a href="#第八章作业解题报告" class="headerlink" title="第八章作业解题报告"></a>第八章作业解题报告</h1><h2 id="1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。"><a href="#1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。" class="headerlink" title="1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。"></a>1：只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算MLFQ的执行记录。限制每项作业的长度并关闭IO。让你的生活更轻松。</h2><p>解：</p><p>根据题目要求，使用命令行观察两个工作两个队列下的工作行为记录：</p><p><code>./mlfq.py -j 2 -n 2 -m 10 -M 0 -c</code></p><p>即设置工作最大长度为10，IO请求为0的两个工作，现在观察到两个工作MLFQ的执行记录如下：</p><p><img alt="joblist" data-src="C:%5CUsers%5C123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571054606381.png"></p><p>时间片记录如下：</p><img alt="1571054650052" style="zoom: 80%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1571054650052.png"><p>最终统计结果如下：</p><p><img alt="1571054711943" data-src="C:%5CUsers%5C123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571054711943.png"></p><h2 id="3-将如何配置调度程序参数，像轮转调度程序那样工作"><a href="#3-将如何配置调度程序参数，像轮转调度程序那样工作" class="headerlink" title="3.将如何配置调度程序参数，像轮转调度程序那样工作?"></a>3.将如何配置调度程序参数，像轮转调度程序那样工作?</h2><p>解：</p><p>轮转调度在第七章给出了定义，为：RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成</p><p>我们现在要实现程序像轮转调度程序那样工作，即取消所有队列，只包含一个队列，即将所有工作放在同一个队列，拥有相同优先级即可，相应命令行如下：</p><p><code>./mlfq.py -j 3 -n 1 -m 20 -q 1 -M 0 -c</code></p><p>即- j 3 表示有三个工作，n 1 表示只有一个队列，即所有程序在同一个优先级，每时间片切换一次程序，同时-m 20表示工作长度最大为20，-q 1 表示时间片为1</p><p>得到的运行结果如下：</p><p><img alt="1571055722292" data-src="C:%5CUsers%5C123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571055722292.png"></p><p>时间统计：</p><img alt="1571055842320" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1571055842320.png"><p>可以看到三个工作长度为 17 8 10，轮转时间为 1 2 3，即每个时间片轮转一次程序，符合轮转调度。</p><h2 id="5-给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别-带有-B标志-，以保证一个长时间运行-并可能饥饿-的工作得到至少5-的-CPU"><a href="#5-给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别-带有-B标志-，以保证一个长时间运行-并可能饥饿-的工作得到至少5-的-CPU" class="headerlink" title="5.给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别(带有-B标志)，以保证一个长时间运行(并可能饥饿)的工作得到至少5% 的 CPU?"></a>5.给定一个系统，其最高队列中的时间片长度为10ms，你需要如何频繁地将工作报回到最高优先级级别(带有-B标志)，以保证一个长时间运行(并可能饥饿)的工作得到至少5% 的 CPU?</h2><p>解：</p><p>该问题可以从两个层面考虑，<strong>一个是系统，一个是工作</strong>：</p><p><strong>系统方面</strong>：要保证一个长时间运行并且可能饥饿的工作能获得至少5%的CPU，由于系统带有-B标志，那么我们需要设计每隔一段时间，将所有工作推回到最高优先级，这个时间常量计算如下：<br>$$<br>S = 10/0.05 = 2000;<br>$$<br>也就是我每隔2000ms，即两秒就将所有工作放入最高优先级，即可保证长时间运行的工作获得至少5%的CPU。</p><p><strong>工作方面</strong>：最高队列的时间片长度为10ms，即如果工作在最高队列运行10秒钟，那么该工作会被降级。现在，如果我每9秒发起一次I/O请求，访问一个不相关的文件，并且不做任何操作，那么我就永远不会被降级，能最大化的保证我在CPU上的运行时间，这既是所谓的“愚弄调度程序”。</p><h1 id="第九章-作业解题报告"><a href="#第九章-作业解题报告" class="headerlink" title="第九章 作业解题报告"></a>第九章 作业解题报告</h1><h3 id="1-计算3个工作在随机种子为1-2和3时的模拟解。"><a href="#1-计算3个工作在随机种子为1-2和3时的模拟解。" class="headerlink" title="1.计算3个工作在随机种子为1.2和3时的模拟解。"></a>1.计算3个工作在随机种子为1.2和3时的模拟解。</h3><p>解：</p><p>随机种子为1 时，执行命令行：</p><p><code>./lottery.py -j 3 -s 1 -c</code></p><p>-j 3 表示三个工作。-s 1 表示种子1，得到结果如下：</p><p><img alt="1571062256043" data-src="C:%5CUsers%5C123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571062256043.png"></p><h3 id="2-现在运行两个具体的工作每个长度为10，但是一个-工作0-只有一张彩票，一个-工作1-有100张-1-10-1-10-100-。彩票数量如此不平衡时会发生什么-在工作1-完成之前，工作0是否会运行-多久-一般来说，这种彩票不平衡对彩票调度的行为有什么影响"><a href="#2-现在运行两个具体的工作每个长度为10，但是一个-工作0-只有一张彩票，一个-工作1-有100张-1-10-1-10-100-。彩票数量如此不平衡时会发生什么-在工作1-完成之前，工作0是否会运行-多久-一般来说，这种彩票不平衡对彩票调度的行为有什么影响" class="headerlink" title="2.现在运行两个具体的工作每个长度为10，但是一个(工作0)只有一张彩票，一个(工作1)有100张(-1 10 : 1 , 10 : 100)。彩票数量如此不平衡时会发生什么?在工作1 完成之前，工作0是否会运行?多久?一般来说，这种彩票不平衡对彩票调度的行为有什么影响?"></a>2.现在运行两个具体的工作每个长度为10，但是一个(工作0)只有一张彩票，一个(工作1)有100张(-1 10 : 1 , 10 : 100)。彩票数量如此不平衡时会发生什么?在工作1 完成之前，工作0是否会运行?多久?一般来说，这种彩票不平衡对彩票调度的行为有什么影响?</h3><p>解：</p><p>两个工作具有相同的工作时间，但是彩票数量却如此不平衡，可能会导致两个工作的运行时间有极大的差别，它们的完成时间也会差别非常大。在工作1完成之前，工作 0 有 0.09% 的运行概率。大概会运行一个长度的时间。</p><p>这种不平衡的彩票数量会使彩票调度的初始目标（确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间）发生偏离。</p><p>模拟结果：</p><img alt="1571063647006" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1571063647006.png"><p><img alt="1571063691792" data-src="C:%5CUsers%5C123456%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1571063691792.png"></p><p>可以看到工作1 在时间10完成，但是工作0在时间20才完成，两个工作运行时间相同的程序完成时间差距巨大</p><h3 id="3-如果运行两个长度为100的工作，都有100张彩票-1100-100-100-100-，调度程序有多不公平-运行一些不同的随机种子来确定-概率上的-答案。不公平性取决于项工作比另一项工作早完成多少。"><a href="#3-如果运行两个长度为100的工作，都有100张彩票-1100-100-100-100-，调度程序有多不公平-运行一些不同的随机种子来确定-概率上的-答案。不公平性取决于项工作比另一项工作早完成多少。" class="headerlink" title="3.如果运行两个长度为100的工作，都有100张彩票(-1100:100,100:100)，调度程序有多不公平?运行一些不同的随机种子来确定(概率上的)答案。不公平性取决于项工作比另一项工作早完成多少。"></a>3.如果运行两个长度为100的工作，都有100张彩票(-1100:100,100:100)，调度程序有多不公平?运行一些不同的随机种子来确定(概率上的)答案。不公平性取决于项工作比另一项工作早完成多少。</h3><p>如果长度相同，彩票数相同，我们期望它们的完成时间大致相同，运行不同种子得到工作时间完成表：</p><table><thead><tr><th>随机种子\完成时间</th><th>job0</th><th>job1</th><th>不公平因子U</th></tr></thead><tbody><tr><td>0</td><td>192</td><td>200</td><td>0.96</td></tr><tr><td>1</td><td>200</td><td>196</td><td>0.98</td></tr><tr><td>2</td><td>200</td><td>190</td><td>0.95</td></tr><tr><td>3</td><td>196</td><td>200</td><td>0.98</td></tr></tbody></table><p>可以看到不公平因子解决于1，已经接近公平。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;学号：201708010720                 姓名：钟京华            班级： 计科1707&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;第八章作业解题报告&quot;&gt;&lt;a href=&quot;#第八章作业解题
      
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="作业" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第九章学习笔记</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/14/操作系统第九章/</id>
    <published>2019-10-14T05:01:03.000Z</published>
    <updated>2019-10-14T15:16:08.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-调度：比例份额"><a href="#第九章-调度：比例份额" class="headerlink" title="第九章 调度：比例份额"></a>第九章 调度：比例份额</h1><p><strong>比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定的CPU时间，而不是优化周转时间和响应时间</strong></p><h2 id="9-1-基本概念-彩票数表示份额"><a href="#9-1-基本概念-彩票数表示份额" class="headerlink" title="9.1 基本概念: 彩票数表示份额"></a>9.1 基本概念: 彩票数表示份额</h2><p>彩票数代表了进程（或者用户或者其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p><p><strong>利用随机性可以保证彩票数多的进程占用CPU时间多。</strong></p><h2 id="9-2彩票机制"><a href="#9-2彩票机制" class="headerlink" title="9.2彩票机制"></a>9.2彩票机制</h2><p><strong>规则3：工作进入系统时，放在最高优先级</strong></p><p><del><strong>规则4a：工作用完整个时间片后，降低其优先级</strong></del></p><p>彩票货币机制：一个用户可以任意的将彩票分给所拥有的进程，而操作系统会将这种彩票自动的转换成全局彩票。</p><p>彩票转让：一个进程可以临时将自己的彩票交给另一个进程。</p><p>彩票膨胀： 一个进程可以临时提升或降低自己拥有的彩票数量。</p><h2 id="9-3实现"><a href="#9-3实现" class="headerlink" title="9.3实现"></a>9.3实现</h2><p>彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。</p><p>用链表实现：不断遍历链表直到找到某个用户拥有目标彩票number，</p><h2 id="9-4一个例子"><a href="#9-4一个例子" class="headerlink" title="9.4一个例子"></a>9.4一个例子</h2><p>假设有两个工作，它们有相同的彩票和运行时间，在这种情况下，我们希望两个工作在大约同时完成，单由于算法的随机性，它们不会同时完成。</p><p>引入不公平指标U：将两个工作完成时刻相除即可得到U的值。</p><p>如，工作1在10完成，工作2在20完成</p><p>此时U = 10/20 = 0.5；</p><h2 id="9-5如何分配彩票"><a href="#9-5如何分配彩票" class="headerlink" title="9.5如何分配彩票"></a>9.5如何分配彩票</h2><p>彩票分配目前没有最佳答案</p><h2 id="9-6-为什么不是确定的"><a href="#9-6-为什么不是确定的" class="headerlink" title="9.6 为什么不是确定的"></a>9.6 为什么不是确定的</h2><p><strong>步长调度</strong>可以保证确定性；</p><p><strong>规则5：在经过一段时间S，就将系统中所有工作重新加入最高优先级队列</strong></p><p>但是在解决新进程加入时随机性表现更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第九章-调度：比例份额&quot;&gt;&lt;a href=&quot;#第九章-调度：比例份额&quot; class=&quot;headerlink&quot; title=&quot;第九章 调度：比例份额&quot;&gt;&lt;/a&gt;第九章 调度：比例份额&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;比例份额算法基于一个简单的想法：调度程序的最终目标，
      
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第九章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论第二章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E6%99%BA%E8%83%BDagent/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/12/第二章 智能agent/</id>
    <published>2019-10-12T13:53:47.366Z</published>
    <updated>2019-10-14T05:18:58.779Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="第二章-智能agent"><a href="#第二章-智能agent" class="headerlink" title="第二章 智能agent"></a>第二章 智能agent</h1><p><strong>Agent：表示能够行动的某种东西；</strong></p><a id="more"></a><h2 id="2-1Agent和环境"><a href="#2-1Agent和环境" class="headerlink" title="2.1Agent和环境"></a>2.1Agent和环境</h2><p>Agent通过传感器感知环境，并通过执行器对所处环境产生影响。</p><h2 id="2-2理性Agent"><a href="#2-2理性Agent" class="headerlink" title="2.2理性Agent"></a>2.2理性Agent</h2><p>理性A是做正确事情的Agent。</p><p>Agent的性能通过<strong>性能度量</strong>评价好坏。</p><p>性能度量：对环境状态的任何给定序列进行评估。</p><p><strong>理性Agent定义</strong>：对每一个可能的感知序列，根据已知的感知序列提供的证据和Agent具有的先验知识，理性Agent应该选择能使其性能度量最大化的行动。</p><p>理性是使期望的性能最大化，而完美是使实际的性能最大化。完美对于Agent而言是不太合理的要求。</p><p>信息收集是理性的重要部分。</p><p>如果一个Agent依赖于设计人员的先验知识而不是它自身的感知信息，这种情况我们会说Agent缺乏自主性。理性Agent应该是自主的–它应该学习，以弥补不完整的或者不正确的先验知识。</p><p>很少要求Agent一开始就完全自主，给人工智能的Agent提供一些初始知识以及学习能力是合理的。</p><p>与学习相结合使得我们可以设计在很多不同环境下都能成功的理性Agent。</p><h2 id="2-3环境的定义"><a href="#2-3环境的定义" class="headerlink" title="2.3环境的定义"></a>2.3环境的定义</h2><p>规定的性能度量、环境以及Agent的执行器和传感器，都属于任务环境。称之为PEAS描述。</p><p><strong>完全可观察的</strong>：如果Agent的传感器在每个时间点上都能获取环境的完整状态，那么我们就说任务环境是完全可观察的。如果传感器能够检测所有与行动决策相关的信息，那么该任务环境是有效完全可观察的。</p><p>与之相对的是<strong>部分可观察</strong>。</p><p><strong>单Agent与多Agent</strong></p><p>单Agent独自运行 eg.字谜游戏</p><p>多Agent同时运行 eg.国际象棋，竞争性的多agent环境</p><p>多人驾驶：避免发生冲撞使得所有Agent的性能度量最大化，所以它是一个部分合作的多Agent环境。</p><p><strong>确定的</strong>：如果环境的下一个状态完全取决于当前状态和Agent执行的动作，那么我们就说该环境是确定的；否则，它是<strong>随机的</strong>。</p><p><strong>片段式的与延续式的</strong>：在片段式的任务环境中，Agent的经历被分成了一个个原子片段。在每个片段中Agent的感知信息并完成单个行动。关键的是，下一个片段不依赖于以前的片段中采取的行动。</p><p>在延续式环境中，当前的决策会影响到所有未来的决策。</p><p><strong>静态的与动态的</strong>：如果环境在Agent计算的时候会变化，那么我们称该Agent的环境是动态的；否则环境是静态的。</p><p>动态环境会持续地要求Agent做决策；如果Agent没有做出决策，Agent则认为它决定不作任何事情。</p><p>如果环境本身不随时间变化而变化，但是Agent的性能评价随时间变化，我们称这样的决策为<strong>半动态</strong>的。</p><p><strong>离散的与连续的</strong>。环境的状态，时间的处理方式以及agent的感知信息和行动都有离散/连续之分。</p><p><strong>已知的和未知的</strong>。</p><h2 id="2-4Agent的结构"><a href="#2-4Agent的结构" class="headerlink" title="2.4Agent的结构"></a>2.4Agent的结构</h2><p><strong>Agent = 体系结构 + 程序</strong></p><p>本书中我们设计的Agent程序都具有相同的框架：输入为从传感器得到的当前感知信息，返回的是执行器的行动抉择。</p><p>Agent的表驱动方法：</p><p><strong>缺点</strong>：</p><p>Ø表太大</p><p>Ø创建表时间长</p><p>Ø非自主性，需人工填写</p><p>Ø即使能够学习，也需要很长的时间</p><p><strong>Agent的类型</strong>：</p><p>Ø简单反射agent</p><p>Ø基于模型的反射agent</p><p>Ø基于目标的agent</p><p>Ø基于效用的agent</p><p><strong>简单反射agent</strong>：</p><img alt="1570863454367" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863454367.png"><p><strong>基于模型的agent：</strong></p><img alt="1570863522199" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863522199.png"><p><strong>基于目标的agent</strong></p><p>除了根据感知信息之外，还要根据目标信息来选择行动</p><p>效率比较低，需要推理</p><p>搜索和规划算法</p><img alt="1570863592280" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863592280.png"><p><strong>基于效用（utility）的agent</strong>：</p><p>当达到目标的行为有很多种的时候，需要考虑效率</p><p>环境是部分可观察的和随机的，不确定下的决策过程可以通过基于效用的agent来实现。</p><p>效用的作用：</p><p>Ø多目标相冲突时，折中方案</p><p>Ø多目标在不确定环境中</p><p>Ø一个目标有多种行为可以达到时</p><img alt="1570863740202" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863740202.png"><p><strong>学习Agent</strong></p><p>四个部件：</p><p>Ø性能元件：相当于整个agent</p><p>Ø评判元件：反映性能元件做得如何</p><p>Ø学习元件：负责改进提高</p><p>Ø问题产生器：提出一些新的有建设性的探索尝试</p><img alt="1570863807685" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570863807685.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Agent是可以感知环境并在环境中行动的事物。Agent函数指定Agent响应任何感知序列所采取的行动</li><li>性能度量评价Agent在环境中的行为表现。给定Agent感知序列，理性Agent行动追求性能度量预期值最大化。</li><li>任务环境的规范包括性能度量、外部环境、执行器和传感器。设计Agent时，第一步总是把任务空间定义得尽可能完全。</li><li>任务环境从不同的维度看有很多变化、它们可能是完全或部分可观察的，单Agent或多Agent的，确定的或随机的，片段式的或延续式的，静态的或动态的，离散的或连续的，已知的或未知的。</li><li>Agent程序是Agent函数的实现。</li><li>简单反射Agent直接对感知信息作出反应，基于模型的反射Agent保持内部状态，追踪记录当前感知信息中反映不出来的世界各个方面。基于目标的Agent的行动是为了达到目标，基于效用的Agent试图最大化它期望的“快乐”</li><li>所有Agent都可以通过学习来改进它们的性能。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;第二章-智能agent&quot;&gt;&lt;a href=&quot;#第二章-智能agent&quot; class=&quot;headerlink&quot; title=&quot;第二章 智能agent&quot;&gt;&lt;/a&gt;第二章 智能agent&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Agent：表示能够行动的某种东西；&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第二章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能导论第一次作业</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/12/%E4%BD%9C%E4%B8%9A%E4%B8%80%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/12/作业一解题报告/</id>
    <published>2019-10-12T13:53:47.330Z</published>
    <updated>2019-10-14T05:22:12.942Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="作业一解题报告"><a href="#作业一解题报告" class="headerlink" title="作业一解题报告"></a>作业一解题报告</h1><a id="more"></a><p><strong>1.考虑一个实时的在线电话翻译系统，该系统实现英语与日语之间的实时在线翻译，讨论该系统的性能度量，环境，执行器，感知器，并对该环境的属性进行分析。</strong></p><p>​    解答：</p><ul><li><p>性能度量：翻译的正确性，保证翻译不能偏离原来的语义；翻译的速度，不能有过高的延迟，否则就不能完成 “实时”；</p></li><li><p>环境：首先是声源噪音，除了有意义的对话外，麦克风还可能接收到各种各样的噪音，例如风声等；然后是电话线路，声音在传播过程中的线路；除此之外，翻译系统还需要考虑每个人不同的口音，每个人说的话波长频率都不一样。</p></li><li><p>执行器：喇叭，音响等发声器</p></li><li><p>感知器：麦克风，接收声音。</p></li><li><p>环境的属性：</p><p>1、完全可观察的：可以获取声音的全部属性。</p><p>2、单Agent，显然只有它本身一个Agent。</p><p>3、随机的，你无法根据自身的状态决定需要翻译的对象下一句话说什么。</p><p>4、现在的翻译系统大多会联系上下文，所以是连续式的，当然，如果本翻译系统只是一个单词翻译一个单词，那么就是片段式的。</p><p>5、动态的，声音来源可能不断的输入以致Agent需要不断地进行翻译，而且根据下一个单词或句子的不同本次翻译的单词意思可能也不一样。</p><p>6、连续的，翻译过程是一个连续的过程。</p><p>7、已知的，语法规则是设计人员知道的。</p></li></ul><p><strong>2.考虑一个医疗诊断系统的agent，讨论该agent最合适的种类(简单agent,基于模型的agent,基于目标的agent和基于效用的agent)并解释你的结论。</strong></p><p>解答：</p><p>基于效用的agent；原因：疾病诊断需要综合很多因素，同一种表现可能是由不同的疾病引起的（例如胃痛可能是肠胃炎、胃穿孔引起，更糟糕的是胃癌引起），所以需要综合不同的因素做出最可能患的疾病的决策，这和效用模型类似——做出使其期望效用最大化的选择，即最可能的选择。</p><p><strong>3.先建立一个完整的搜索树，起点是S,终点是G,如下图,节点旁的数字表示到达目标状态的距离，然后用以下方法表示如何进行搜索，并分析几种算法的完备性、最优性、以及时间复杂度和空间复杂度。</strong></p><p>解答：</p><p>搜索树：</p><img alt="1570882949017" style="zoom:67%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570882949017.png"><p>深度优先：</p><img alt="1570882988966" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570882988966.png"><p>从开始节点s，不断深度搜索，可以一直搜索直到到达终点G。</p><p>完备性：在有限空间是完备的，因为它至多扩展所有节点，在无限状态空间中，遭遇了无限又无法到达的节点，则不完备。</p><p>最优性：不是最优的，返回的是最先找到的解，而不是最优解。</p><p>时间复杂度：考虑空间分子为b最大深度为m，那么时间复杂度为 :<br>$$<br>O(b^m)<br>$$<br>空间复杂度：<br>$$<br>O(bm)<br>$$</p><p>宽度优先：</p><img alt="1570883063466" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883063466.png"><p>完备性：是完备的，如果目标节点存在于一个有限深度d，那么宽度优先搜索能找到它。</p><p>最优性：不是最优的，返回的是最浅的解，而不是最优解。</p><p>时间复杂度：假设每个状态有b个后继，d为深度 :<br>$$<br>O(b^d)<br>$$<br>空间复杂度：<br>$$<br>O(b^d)<br>$$<br>爬山法：</p><img alt="1570883096745" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883096745.png"><p>从s节点开始，每次寻找代价最小的，直到达到最终节点G</p><p>完备性：不是完备的，找到的是局部最优，不一定是全局最优。</p><p>最优性：不一定能找到最优解。</p><p>时间复杂度：最多遍历n个节点，所以时间复杂度为<br>$$<br>O(n)<br>$$<br>空间复杂度：同时间复杂度，为<br>$$<br>O(n)<br>$$<br>最佳优先：</p><img alt="1570883160240" style="zoom:50%;" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570883160240.png"><p>从s节点开始，先找节点A，此时节点A的代价为8，然后找节点B，代价为9，然后找节点D，代价为23，,然后扩展节点G得到结果。</p><p>完备性：不是完备的，<strong>可能会陷入死循环</strong>。</p><p>最优性：不一定能找到最优解。</p><p>时间复杂度：设搜索空间的最大深度是m，一个结点会有b个后继结点，最坏情况下，时间复杂度为<br>$$<br>O(b^m)<br>$$<br>空间复杂度：同时间复杂度，为<br>$$<br>O(b^m)<br>$$<br><strong>4.图二是一棵部分展开的搜索树，其中树的边记录了对应的单步代价，叶子节点标注了到达目标结点的启发式函数的代价值，假定当前状态位于结点A。</strong></p><p><strong>a)       用下列的搜索方法来计算下一步需要展开的叶子节点。注意必须要有完整的计算过程，同时必须对扩展该叶子节点之前的节点顺序进行 记录：</strong></p><ol><li><p><strong>贪婪最佳优先搜索</strong></p></li><li><p><strong>一致代价搜索</strong></p></li><li><p><strong>A*树搜索</strong></p></li></ol><p><strong>(b)  讨论以上三种算法的完备性和最优性。</strong></p><img alt="1570887643455" data-src="C:\Users\123456\AppData\Roaming\Typora\typora-user-images\1570887643455.png"><p>​                                                                        图二</p><p>a)    1、贪婪最佳优先搜索，即试图扩展离目标节点最近的节点，因此只采用启发式，即</p><p>  f(n) = h(n)  </p><p>由图可知<br>$$<br>h(c) = 5, h(D) = 10,h(E) = 10,h(F) = 12, h(G)=8,h(H)=10<br>$$<br>注意到h(B) 没有给出，因此，如果h(B)&gt;5,首先访问叶子结点C,如果h(B)&lt;=5,首先访问B,再访问C.</p><p>2、一致代价搜索，即按照g（n）升序搜索，由图可知：<br>$$<br>g(B)= 3,g(C) = 19, g(D) = 5, g(E) = 6, g(F) = 8, g(G) = 9, g(H) = 9<br>$$<br>所以搜索顺序为BDEFGHC，下一步搜索的节点为B</p><p>3、A*树搜索，即缩小总评估代价，由于<br>$$<br>f(n) = g(n) + h(n)<br>$$<br>可知各个节点f(n)为<br>$$<br>f(B)=?,  f(C) = 24, f(D) = 18, f(E) = 16, f(F) = 20, f(G) = 17, f(H) = 19<br>$$<br>故如果h(B)&gt;15,首先访问D如果h(B)&lt;=15,首先访问B,再访问E,G,D,H,F,C</p><p>b)</p><p>贪婪最佳优先搜索：</p><p>完备性：即使是有限状态空间，搜索路径遇到环也会失败，或者是无限状态下，此时也是不完备的</p><p>最优性：它的搜索代价是最小的，但是却不是最优的。</p><p>一致代价搜索：</p><p>完备性：如果存在零代价，则会陷入死循环，此时不是完备的，其它情况都是完备的</p><p>最优性：一定能找到最优解</p><p>A*树搜索</p><p>完备性：是完备的，能找到解</p><p>最优性：如果h(n)启发式函数是可采纳的，那么A* 的树搜索是最优的，如果h(n)是一致的，那么图搜索的A*算法是最优的</p><p><strong>5.给定一个启发式函数满足h(G)=0,其中G是目标状态，证明如果h是一致的，那么它是可采纳的。</strong></p><p>解答：</p><p>假设n为任意一个状态，G是任意一个目标状态，1,2,3..，m为从状态n到达G的一条最优路径，<br>$$<br>已知评估代价为f(n) = g(n)+ h(n)<br>$$</p><p>$$<br>真实代价f’(n)=g(n)+c(n,a1,n1)+c(n1,a2,n2)+….c(nm,am+1,G)<br>$$</p><p>$$<br>那么：f(n)=g(n)+h(n)&lt;=g(n)+c(n,a1,n1)+h(n1)<br>$$</p><p>$$<br>&lt;=g(n)+c(n,a1,n1)+c(n1,a2,n2)+h(n2)<br>$$</p><p>$$<br>&lt;=…..&lt;=g(n)+c(n,a1,n1)+c(n1,a2,n2)+….c(nm,am+1,G)+h(G)<br>$$</p><p>$$<br>=f’(n）<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;作业一解题报告&quot;&gt;&lt;a href=&quot;#作业一解题报告&quot; class=&quot;headerlink&quot; title=&quot;作业一解题报告&quot;&gt;&lt;/a&gt;作业一解题报告&lt;/h1&gt;
    
    </summary>
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="人工智能导论" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="作业" scheme="http://shenqidaxiansheng.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第七章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操作系统导论第七章/</id>
    <published>2019-10-08T09:43:11.612Z</published>
    <updated>2019-10-08T10:17:08.883Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第七章：进程调度"><a href="#操作系统导论第七章：进程调度" class="headerlink" title="操作系统导论第七章：进程调度"></a>操作系统导论第七章：进程调度</h1><p>操作系统该如何决定切换进程？如何运行进程使得效率最大化？</p><a id="more"></a><h2 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h2><p>1、周转时间<br>$T_{周转时间}=T_{完成时间}-T_{到达时间}$<br>2、响应时间<br>$T_{响应时间}=T_{第一次执行时间}-T_{到达时间}$</p><h2 id="先进先出（FIFO）调度原则"><a href="#先进先出（FIFO）调度原则" class="headerlink" title="先进先出（FIFO）调度原则"></a>先进先出（FIFO）调度原则</h2><p>假设3个工作 a，b，c工作长度为10s，它们大致在相同时间到达（$T_{到达}=0$)但是a比b稍微早一点点，b比c稍微早一点点。<br>那么平均周转时间是$T=(10+20+30)/3 = 20$<br>但是假设a = 100，b和c仍然是10<br>那么平均周转时间是$T=(100+110+120)/3 = 110$<br>可以看出，FIFO调度策略对周转时间不友好</p><h2 id="最短任务优先-（SJF）"><a href="#最短任务优先-（SJF）" class="headerlink" title="最短任务优先 （SJF）"></a>最短任务优先 （SJF）</h2><p>仍然考虑a = 100，b和c仍然是10的情况<br>平均周转时间是$T=(10+20+120)/3 = 50$<br>但是，如果abc不是同时到达，而是a先到达，那么平均周转时间和FIFO一样了。</p><h2 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h2><p>为了解决这个问题，我们让最短完成时间的任务先运行，那么即使是a先到达，但在bc到达时切换到bc进程运行，这样平均周转时间就又恢复成50s。</p><h2 id="轮转（RR）调度策略"><a href="#轮转（RR）调度策略" class="headerlink" title="轮转（RR）调度策略"></a>轮转（RR）调度策略</h2><p>前面都只是针对周转时间，但是响应时间如何（在一个好的交互系统，响应时间尤为重要，用户不会愿意等它前面的进程完成后才响应当前进行的操作）<br>这就引出了一种新的调度算法：轮转<br>RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成。</p><h2 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h2><p>当进程请求I/O时，操作系统可以切换下一个进程，等进程I/O请求完成后，再切换回来，提升CPU使用效率。</p><h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><p>1、</p><p>SJF为最短任务优先原则，现在用这个策略调度长度为200的3个作业，由于作业长度一样（都为200），则假设a、b、b先后运行，那么各个响应周转时间应该如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173735334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>-c测试：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173802907.png"></p><p>与计算相符。</p><p>FIFO为先进先出策略，即先到的任务先运行，由于三个作业长度都为200，所以结果应该与SJF策略相同，-c测试：</p><p>一样。</p><p>2、</p><p>采用SJF策略调度，那么先后运行的任务是 100 200 300</p><p>假设它们为a b c 任务，那么各个时间计算如下：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173857430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173920851.png"><br>采用FIFO策略，假设任务到达的先后顺序为 100 200 300</p><p>那么需要的各个时间应该与SJF调度是一样的。如果是 300 200 100，那么需要的时间不同：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008173932306.png"></p><p>3、</p><p>RR调度程序，即轮转调度，在一个时间片（time<br>slice，有时称为调度量子）内运行一个工作，然后切换到队列的下一个任务，即每个时间片切换一个不同的程序，反复执行，直到所有任务完成。时间片必须是时钟中断周期的倍数，因为它依靠时钟周期中断实现。</p><p>现在时间片为1，即每隔一秒切换一次，各个时间应该如下：（仍然假设各个任务为 a b c）<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174013520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"></p><p>4、<br>1、在相同时间到达，运行相同时间的任务</p><p>2、在不同时间到达，但是任务的到达顺序是运行时间由短到长。</p><p>这两种类型的工作负载的周转时间都相同。</p><p>5、</p><p>每个工作的工作负载和量子长度相同时，SJF与RR提供相同的响应时间。</p><p>6、</p><p>SJF的其它工作（除了第一份工作，因为它是第一个运行，响应时间为0）响应时间会随着工作长度的增加而增加。</p><p>现在我假设三个工作（依然是 a b c），我将从100 200 300 开始不断的增加长度，使用模拟程序查看平均响应时间，得到结果如下：</p><p><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20191008174120557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"> </p><p>可以看到，平均响应时间确实是随着工作长度的增加而增加。</p><p>7、</p><p>显然，随着量子长度的增加，RR的响应时间也会随着增加。</p><p>最坏情况：首先我们假设这N个工作的到达顺序为从最长的到最短的，假设它们的序号为1,2，3…N，量子长度为S</p><p>且最长的工作（序号为1）的工作长度为小于等于量子长度即</p><p>1&lt;=S;</p><p>那么，这组工作的响应时间即是前N-1个工作长度的总合，即为</p><p>1+2+3+4+…+（N-1）</p><p>（注意这里的数字1,2,3,4表示的是工作的序号，不是工作长度，它们的工作长度顺序是1&gt;2&gt;3&gt;4..）</p><p>即最坏情况下的响应时间是<strong>除了长度最短的工作</strong>的<strong>所有工作长度的总合</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;a href=&quot;#操作系统导论第七章：进程调度&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第七章：进程调度&quot;&gt;&lt;/a&gt;操作系统导论第七章：进程调度&lt;/h1&gt;&lt;p&gt;操作系统该如何决定切换进程？如何运行进程使得效率最大化？&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第七章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第六章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/10/08/%E6%93%8D%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/10/08/操行系统导论第六章/</id>
    <published>2019-10-08T08:55:42.863Z</published>
    <updated>2019-10-08T08:55:42.864Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="操作系统导论第六章：受限直接运行"><a href="#操作系统导论第六章：受限直接运行" class="headerlink" title="操作系统导论第六章：受限直接运行"></a>操作系统导论第六章：受限直接运行</h1><p>第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。<br>然而这样带来了一些问题：<br>1、如何在不增加系统开销的情况下实现虚拟化？<br>2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）</p><p>操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。</p><a id="more"></a><h2 id="基本技巧-受限直接运行"><a href="#基本技巧-受限直接运行" class="headerlink" title="基本技巧:受限直接运行"></a>基本技巧:受限直接运行</h2><p>为了使程序尽可能快地运行，只需直接在CPU上运行程序即可，但是为了解决上面提到的问题，我们必须给予运行程序一些限制。</p><h2 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h2><p>当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中，找到入口点（main（）），跳转到哪里，并开始运行用户的代码。</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>为了限制进程的运行，硬件 通过提供不同的执行模式来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源（操作系统就处于这一模式下）。<br>但是在用户模式下，给予一些方式使得程序能够短暂进入内核模式是有必要的。因为大部分的应用程序都需要进行I/O和其他相关操作。<br>现代硬件提供了用户程序执行系统调用的能力。<br>要执行系统调用，程序必须执行特殊的陷阱指令。该指令同时跳入内核并将特权级别提升到内核模式。完成所需的工作后，操作系统调用一个特殊的从陷阱返回的指令，应用程序回到用户模式。</p><h2 id="在进程中切换"><a href="#在进程中切换" class="headerlink" title="在进程中切换"></a>在进程中切换</h2><p>当一个进程在CPU上运行时，就意味着操作系统没有运行，那么操行系统应该如何决定停止一个进程并开始另一个进程？显然，一个没有运行的操作系统是无法执行任何操作的。<br>那么，操作系统应该如何在进程运行时重获CPU的控制权？<br>协作方式：等待系统调用。<br>过去系统采用这种等待进程进行系统调用的方式，当进程进行系统调用时，将控制权交给操作系统。<br>但是，如果一个进程永远不进行系统调用，也不出错，那么这种方式就无法解决问题了。<br>为此操作系统采用时钟中断来重获控制权。</p><h2 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h2><p>如果操作系统决定切换进程，那么操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核指针，然后恢复即将切换的程序的上下文，并切换栈。<br>通过切换栈，内核在进入切换代码调用时，是被中断进程的上下文，在返回时，是另一个进程的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;a href=&quot;#操作系统导论第六章：受限直接运行&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第六章：受限直接运行&quot;&gt;&lt;/a&gt;操作系统导论第六章：受限直接运行&lt;/h1&gt;&lt;p&gt;第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。&lt;br&gt;然而这样带来了一些问题：&lt;br&gt;1、如何在不增加系统开销的情况下实现虚拟化？&lt;br&gt;2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环）&lt;/p&gt;
&lt;p&gt;操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第六章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第五章</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/25/操作系统导论第五章/</id>
    <published>2019-09-24T17:18:23.188Z</published>
    <updated>2019-09-24T17:20:08.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第五章：进程API"><a href="#操作系统导论第五章：进程API" class="headerlink" title="操作系统导论第五章：进程API"></a>操作系统导论第五章：进程API</h1><a id="more"></a><h2 id="UNIX的系统调用"><a href="#UNIX的系统调用" class="headerlink" title="UNIX的系统调用"></a>UNIX的系统调用</h2><p>UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。</p><p>父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。</p><h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><strong><em>先贴一段简单的调用fork函数的代码</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,world.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am child\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am parent\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>运行结果是：</p><p><img alt data-src="https://img-blog.csdnimg.cn/20190925010803571.png"></p><p>可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。<br>说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。<br>注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。</p><h2 id="exec函数调用"><a href="#exec函数调用" class="headerlink" title="exec函数调用"></a>exec函数调用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">execle(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">execlp(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *m[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(<span class="string">"/bin/ls"</span>,m,<span class="literal">NULL</span>);</span><br><span class="line">execv(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line">execvp(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec（）函数族有六个变体<br>根据参数类型，大体可以分为两类：<br>•    以 list 可变参数传参<br>•    execl<br>•    execlp<br>•    execle<br>•    以 vector 数组传参<br>•    execv<br>•    execvp<br>•    execve<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190925011659188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>各个函数变体参数如上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;a href=&quot;#操作系统导论第五章：进程API&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第五章：进程API&quot;&gt;&lt;/a&gt;操作系统导论第五章：进程API&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="第五章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统导论第四章作业解题报告</title>
    <link href="http://shenqidaxiansheng.github.io/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://shenqidaxiansheng.github.io/2019/09/24/操作系统导论第四章模拟作业解题报告/</id>
    <published>2019-09-24T10:11:38.061Z</published>
    <updated>2019-09-24T16:45:32.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统导论第四章：进程"><a href="#操作系统导论第四章：进程" class="headerlink" title="操作系统导论第四章：进程"></a>操作系统导论第四章：进程</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程就是运行中的程序</p><h2 id="一台机器上如何同时运行多个程序？"><a href="#一台机器上如何同时运行多个程序？" class="headerlink" title="一台机器上如何同时运行多个程序？"></a>一台机器上如何同时运行多个程序？</h2><p><strong><em>这里的关键问题是：如何提供有许多CPU的假象？</em></strong></p><p>我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？</p><p>操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。</p><h1 id="模拟作业"><a href="#模拟作业" class="headerlink" title="模拟作业"></a>模拟作业</h1><p>操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载：</p><p><a href="http://http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html" target="_blank" rel="noopener">操作系统导论homework</a>，加载时间可能会常一些，正常等待即可。</p><p>然后从该网站上下载本章需要的作业程序：<em>process-run.py</em>，</p><p>解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。</p><p>博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。</p><p>下面是本章作业1-5题的个人解答，只供参考：</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>1、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180655603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>-c检查：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019092418071355.png"></p><p>和预期相符。</p><p>2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1.</p><p>所以完成这两个进程需要时间为 10；</p><p>检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180729945.png"></p><p>预期相符。</p><p>3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1.</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180754924.png"></p><p>从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。</p><p>4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180820315.png"></p><p>与预期相符</p><p>5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180834685.png"></p><p>与预期相符。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;操作系统导论第四章：进程&quot;&gt;&lt;a href=&quot;#操作系统导论第四章：进程&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论第四章：进程&quot;&gt;&lt;/a&gt;操作系统导论第四章：进程&lt;/h1&gt;
    
    </summary>
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="操作系统导论" scheme="http://shenqidaxiansheng.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="第四章" scheme="http://shenqidaxiansheng.github.io/tags/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
      <category term="模拟作业" scheme="http://shenqidaxiansheng.github.io/tags/%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/15/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/15/新文档/</id>
    <published>2019-08-15T13:42:39.129Z</published>
    <updated>2019-08-15T13:42:39.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中的foreach语法"><a href="#java中的foreach语法" class="headerlink" title="java中的foreach语法"></a>java中的foreach语法</h1><p>形式：for(x:a)<br>例如：<br>   <code>int  a[10], x;</code><br>    <code>for(x:a)</code><br>表示将a数组中的每个元素按下标索引的顺序赋值给x；</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中的foreach语法&quot;&gt;&lt;a href=&quot;#java中的foreach语法&quot; class=&quot;headerlink&quot; title=&quot;java中的foreach语法&quot;&gt;&lt;/a&gt;java中的foreach语法&lt;/h1&gt;&lt;p&gt;形式：for(x:a)&lt;br&gt;例如：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://shenqidaxiansheng.github.io/2019/08/02/index/"/>
    <id>http://shenqidaxiansheng.github.io/2019/08/02/index/</id>
    <published>2019-08-01T19:34:51.000Z</published>
    <updated>2019-08-01T19:34:51.539Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+github 搭建个人博客</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hexo+github 搭建个人博客/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-08-01T19:20:39.275Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://shenqidaxiansheng.github.io/">博主的博客</a><br>觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号</p><ol><li>注册github账号，你可以去这里注册：<a href="https://github.com/" target="_blank" rel="noopener">github登陆界面</a>，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到</li><li>注册号github账号后，就可以去新建一个仓库，：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802012834196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>如图点击new按钮，新建一个仓库，到了这个页面：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802013358361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io<br>新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。</li><li>下载git，可以去这里下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git下载地址</a>，点击download就可以下载了，下载完成安装就可以了</li><li>然后我们再安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2>前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014643948.png"><br>创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014955292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>打开git bash ，不出意外你将得到这个界面：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802031455315.jpg"><br>这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成<br>输入以下代码安装hexo：<br><code>npm install hexo -g</code><br>安装完成后，输入<br><code>hexo init</code><br>完成初始化<br>##关键一步：将hexo和GitHub上创建的仓库联系起来<br>网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦<br>首先，我们先输入以下命令：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.</span> ssh</span><br></pre></td></tr></table></figure><p>如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥<br>输入以下命令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"邮件地址"</span></span><br></pre></td></tr></table></figure><p>邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\id_rsa.pub，例如博主的这个文件就在这：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802020710806.png"><br>用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：<br>点击 new ssh key，是是啊撒大声地大大大是是是<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802021007911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。<br>有了ssh秘钥就可以把本地文件和github上的仓库联系起来<br>继续在gitbash上执行如下命令：<br>    <code>git config --global user.name &quot;username&quot;// 你的github用户名，非昵称</code><br>    <code>git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code><br>这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。</p><p>##将本地博客上传到github上<br>输入以下命令：<br>    <code>hexo g</code><br>    <code>hexo s</code><br>然后在游览器上打开网址：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。<br>然后输入以下命令：<br>    <code>hexo clean</code><br>    <code>hexo g</code><br>    <code>hexo d</code><br>hexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。<br>输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）<br>利用hexo大家博客完成</p><p>##写博客<br>博客搭好后，我们如何写博客并且上传到自己的博客页面？<br>先按照这个路径点开这个文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802023807653.png"><br>这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，<br>执行命令：<br>    <code>hexo new page &quot;my-first-blog&quot;</code><br>就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（<a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">makedown下载地址</a>）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。<br>当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了<br>(╥╯^╰╥)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://shenqidaxiansheng.github.io/&quot;&gt;博主的博客&lt;/a&gt;&lt;br&gt;觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺&lt;/p&gt;
    
    </summary>
    
      <category term="搭建个人博客及美化" scheme="http://shenqidaxiansheng.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8F%8A%E7%BE%8E%E5%8C%96/"/>
    
    
      <category term="hexo" scheme="http://shenqidaxiansheng.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://shenqidaxiansheng.github.io/tags/github/"/>
    
      <category term="个人博客" scheme="http://shenqidaxiansheng.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>四六级词汇学习笔记</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/四六级词汇/</id>
    <published>2019-07-29T07:58:11.000Z</published>
    <updated>2019-07-30T12:39:08.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四六级词汇学习笔记"><a href="#四六级词汇学习笔记" class="headerlink" title="四六级词汇学习笔记"></a>四六级词汇学习笔记</h2><a id="more"></a><p>英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。</p><h2 id="前缀示例："><a href="#前缀示例：" class="headerlink" title="前缀示例："></a>前缀示例：</h2><p>deriver from –源自于<br>deviate from –偏离(deviate脱离）<br>前缀：de -&gt; down(下降)<br>derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于<br>decrease(减少)<br>decline(n.下降，vt 婉拒）<br>(同义词 refus ，reject)<br>前缀re 表示again再一次 或者 back返回<br>retell 再讲一遍<br>return 返回，回报<br>词根fuse = flow 表示流动<br>refuse 表示流回去（拒绝）<br>ject-词根-扔<br>reject 扔回去（强烈的拒绝）</p><p>steam from 也表示源自于的意思<br>steam 名词-根茎<br>originate from 源自于</p><p>discount：n.折扣，v.认为..不重要<br>前缀-dis-表示否定<br>count计算，discount即表示打折扣</p><p>account：n.账目，赊账<br>前缀-ac-强调作用<br>a+辅音<br>（aeiou五个字母为元音字母，其余为辅音字母）<br>（元音字母可以替换但是意思不变，例如：begin-began-begun<br>Man-Men）<br>count-计数，数数<br>counter ：计算器，计数器，柜台<br>作形容词还可表示相反的<br>作副词表示相反地<br>作动词表示反对<br>（OTC：over the counter）<br>counterbalance:制衡（从相反的方向平衡）</p><p>后缀er（和or相同）-表示人或者物）<br>cooker（厨具）<br>tractor（拖拉机）</p><h2 id="后缀示例："><a href="#后缀示例：" class="headerlink" title="后缀示例："></a>后缀示例：</h2><p>origin-n.起源-后缀ate<br>original-adj.原始的-后缀al</p><p>fluctuate 起伏不定<br>后缀-ate：<br>1、名词，例如：graduate毕业生，candidate候选人<br>2、动词，例如：graduate 毕业（动词）<br>3、形容词，例如：private<br>前缀：flu流动<br>fluent：流利的<br>后缀：ent=ant 表示形容词或者名词后缀<br>account，servant，<br>fluid<br>名词 液体，形容词流动的<br>反义词 solid<br>influential<br>前缀：in 表在里面<br>也可表否定，这时一般做形容词前缀</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;四六级词汇学习笔记&quot;&gt;&lt;a href=&quot;#四六级词汇学习笔记&quot; class=&quot;headerlink&quot; title=&quot;四六级词汇学习笔记&quot;&gt;&lt;/a&gt;四六级词汇学习笔记&lt;/h2&gt;
    
    </summary>
    
      <category term="英语学习" scheme="http://shenqidaxiansheng.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="英语学习," scheme="http://shenqidaxiansheng.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="四六级" scheme="http://shenqidaxiansheng.github.io/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shenqidaxiansheng.github.io/2019/07/29/hello-world/"/>
    <id>http://shenqidaxiansheng.github.io/2019/07/29/hello-world/</id>
    <published>2019-07-29T07:02:22.715Z</published>
    <updated>2019-07-29T08:23:27.991Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
