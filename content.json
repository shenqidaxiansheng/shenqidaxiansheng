{"meta":{"title":"一只神奇的DXS","subtitle":"一名计算机学生的个人网站","description":"a computer student","author":"Jing Hua","url":"http://shenqidaxiansheng.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-29T12:23:49.000Z","updated":"2019-07-30T12:37:59.978Z","comments":true,"path":"categories/index.html","permalink":"http://shenqidaxiansheng.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-29T12:22:43.000Z","updated":"2019-07-29T12:26:16.925Z","comments":true,"path":"tags/index.html","permalink":"http://shenqidaxiansheng.github.io/tags/index.html","excerpt":"","text":""},{"title":"test","date":"2019-08-01T19:34:51.000Z","updated":"2019-08-01T19:34:51.539Z","comments":true,"path":"test/index.html","permalink":"http://shenqidaxiansheng.github.io/test/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统导论第七章","slug":"操作系统导论第七章","date":"2019-10-08T09:43:11.612Z","updated":"2019-10-08T10:17:08.883Z","comments":true,"path":"2019/10/08/操作系统导论第七章/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/10/08/操作系统导论第七章/","excerpt":"操作系统导论第七章：进程调度操作系统该如何决定切换进程？如何运行进程使得效率最大化？","text":"操作系统导论第七章：进程调度操作系统该如何决定切换进程？如何运行进程使得效率最大化？ 调度指标1、周转时间$T_{周转时间}=T_{完成时间}-T_{到达时间}$2、响应时间$T_{响应时间}=T_{第一次执行时间}-T_{到达时间}$ 先进先出（FIFO）调度原则假设3个工作 a，b，c工作长度为10s，它们大致在相同时间到达（$T_{到达}=0$)但是a比b稍微早一点点，b比c稍微早一点点。那么平均周转时间是$T=(10+20+30)/3 = 20$但是假设a = 100，b和c仍然是10那么平均周转时间是$T=(100+110+120)/3 = 110$可以看出，FIFO调度策略对周转时间不友好 最短任务优先 （SJF）仍然考虑a = 100，b和c仍然是10的情况平均周转时间是$T=(10+20+120)/3 = 50$但是，如果abc不是同时到达，而是a先到达，那么平均周转时间和FIFO一样了。 最短完成时间优先（STCF）为了解决这个问题，我们让最短完成时间的任务先运行，那么即使是a先到达，但在bc到达时切换到bc进程运行，这样平均周转时间就又恢复成50s。 轮转（RR）调度策略前面都只是针对周转时间，但是响应时间如何（在一个好的交互系统，响应时间尤为重要，用户不会愿意等它前面的进程完成后才响应当前进行的操作）这就引出了一种新的调度算法：轮转RR在一个时间片内运行一个工作，然后切换到运行对了中的下一个任务，而不是运行一个程序直到结束。它反复执行，直到所有任务完成。 结合I/O当进程请求I/O时，操作系统可以切换下一个进程，等进程I/O请求完成后，再切换回来，提升CPU使用效率。 课后作业1、 SJF为最短任务优先原则，现在用这个策略调度长度为200的3个作业，由于作业长度一样（都为200），则假设a、b、b先后运行，那么各个响应周转时间应该如下： -c测试： 与计算相符。 FIFO为先进先出策略，即先到的任务先运行，由于三个作业长度都为200，所以结果应该与SJF策略相同，-c测试： 一样。 2、 采用SJF策略调度，那么先后运行的任务是 100 200 300 假设它们为a b c 任务，那么各个时间计算如下： 采用FIFO策略，假设任务到达的先后顺序为 100 200 300 那么需要的各个时间应该与SJF调度是一样的。如果是 300 200 100，那么需要的时间不同： 3、 RR调度程序，即轮转调度，在一个时间片（timeslice，有时称为调度量子）内运行一个工作，然后切换到队列的下一个任务，即每个时间片切换一个不同的程序，反复执行，直到所有任务完成。时间片必须是时钟中断周期的倍数，因为它依靠时钟周期中断实现。 现在时间片为1，即每隔一秒切换一次，各个时间应该如下：（仍然假设各个任务为 a b c） 4、1、在相同时间到达，运行相同时间的任务 2、在不同时间到达，但是任务的到达顺序是运行时间由短到长。 这两种类型的工作负载的周转时间都相同。 5、 每个工作的工作负载和量子长度相同时，SJF与RR提供相同的响应时间。 6、 SJF的其它工作（除了第一份工作，因为它是第一个运行，响应时间为0）响应时间会随着工作长度的增加而增加。 现在我假设三个工作（依然是 a b c），我将从100 200 300 开始不断的增加长度，使用模拟程序查看平均响应时间，得到结果如下： 可以看到，平均响应时间确实是随着工作长度的增加而增加。 7、 显然，随着量子长度的增加，RR的响应时间也会随着增加。 最坏情况：首先我们假设这N个工作的到达顺序为从最长的到最短的，假设它们的序号为1,2，3…N，量子长度为S 且最长的工作（序号为1）的工作长度为小于等于量子长度即 1&lt;=S; 那么，这组工作的响应时间即是前N-1个工作长度的总合，即为 1+2+3+4+…+（N-1） （注意这里的数字1,2,3,4表示的是工作的序号，不是工作长度，它们的工作长度顺序是1&gt;2&gt;3&gt;4..） 即最坏情况下的响应时间是除了长度最短的工作的所有工作长度的总合。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"第七章","slug":"第七章","permalink":"http://shenqidaxiansheng.github.io/tags/第七章/"}]},{"title":"操作系统导论第六章","slug":"操行系统导论第六章","date":"2019-10-08T08:55:42.863Z","updated":"2019-10-08T08:55:42.864Z","comments":true,"path":"2019/10/08/操行系统导论第六章/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/10/08/操行系统导论第六章/","excerpt":"操作系统导论第六章：受限直接运行第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。然而这样带来了一些问题：1、如何在不增加系统开销的情况下实现虚拟化？2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环） 操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。","text":"操作系统导论第六章：受限直接运行第四章中提到了，操作系统采用时分共享虚拟化CPU的方式，让多种任务能够共享CPU。即运行一个进程一段时间，然后切换另一个进程，如此轮换，使得每个进程各自好似独立互不影响的使用CPU。然而这样带来了一些问题：1、如何在不增加系统开销的情况下实现虚拟化？2、如何有效地运行进程，同时保留对CPU的控制权？（提升：如果对CPU没有控制权，让进程毫无限制地运行CPU，这将带来重大的安全隐患，例如访问不该访问的区域或者陷入死循环） 操作系统开发人员想出来了一种技术，也就是本章的内容：受限直接运行。 基本技巧:受限直接运行为了使程序尽可能快地运行，只需直接在CPU上运行程序即可，但是为了解决上面提到的问题，我们必须给予运行程序一些限制。 直接运行当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中，找到入口点（main（）），跳转到哪里，并开始运行用户的代码。 限制为了限制进程的运行，硬件 通过提供不同的执行模式来协助操作系统。在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源（操作系统就处于这一模式下）。但是在用户模式下，给予一些方式使得程序能够短暂进入内核模式是有必要的。因为大部分的应用程序都需要进行I/O和其他相关操作。现代硬件提供了用户程序执行系统调用的能力。要执行系统调用，程序必须执行特殊的陷阱指令。该指令同时跳入内核并将特权级别提升到内核模式。完成所需的工作后，操作系统调用一个特殊的从陷阱返回的指令，应用程序回到用户模式。 在进程中切换当一个进程在CPU上运行时，就意味着操作系统没有运行，那么操行系统应该如何决定停止一个进程并开始另一个进程？显然，一个没有运行的操作系统是无法执行任何操作的。那么，操作系统应该如何在进程运行时重获CPU的控制权？协作方式：等待系统调用。过去系统采用这种等待进程进行系统调用的方式，当进程进行系统调用时，将控制权交给操作系统。但是，如果一个进程永远不进行系统调用，也不出错，那么这种方式就无法解决问题了。为此操作系统采用时钟中断来重获控制权。 保存和恢复上下文如果操作系统决定切换进程，那么操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核指针，然后恢复即将切换的程序的上下文，并切换栈。通过切换栈，内核在进入切换代码调用时，是被中断进程的上下文，在返回时，是另一个进程的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"第六章","slug":"第六章","permalink":"http://shenqidaxiansheng.github.io/tags/第六章/"}]},{"title":"操作系统导论第五章","slug":"操作系统导论第五章","date":"2019-09-24T17:18:23.188Z","updated":"2019-09-24T17:20:08.855Z","comments":true,"path":"2019/09/25/操作系统导论第五章/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/09/25/操作系统导论第五章/","excerpt":"操作系统导论第五章：进程API","text":"操作系统导论第五章：进程API UNIX的系统调用UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。 父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。 fork（）函数先贴一段简单的调用fork函数的代码 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123;printf(\"hello,world.\\n\");int x = 100;int rc = fork();if(rc&lt;0)&#123;fprintf(stderr,\"fork failed\\n\");exit(1);&#125;else if(rc==0)&#123;printf(\"hello,I am child\\n\");printf(\"x=%d\\n\",x+7);&#125;else&#123;printf(\"hello,I am parent\\n\");printf(\"x=%d\\n\",x+8);&#125;return 0;&#125;` 运行结果是： 可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。 exec函数调用12345678910111213141516171819202122232425262728293031#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/wait.h&gt;int main()&#123;int rc = fork();if(rc&lt;0)&#123;fprintf(stderr,\"fork failed\\n\");exit(1);&#125;else if(rc==0)&#123;printf(\"child\\n\");execl(\"/bin/ls\",\"ls\",\"-l\",NULL);execle(\"/bin/ls\",\"ls\",\"-l\",NULL,NULL);execlp(\"/bin/ls\",\"ls\",\"-l\",NULL);char *m[] = &#123;\"ls\",\"-l\",NULL&#125;;execve(\"/bin/ls\",m,NULL);execv(\"/bin/ls\",m);execvp(\"/bin/ls\",m);exit(1);&#125;else&#123;printf(\"parent\\n\");&#125;return 0;&#125; exec（）函数族有六个变体根据参数类型，大体可以分为两类：• 以 list 可变参数传参• execl• execlp• execle• 以 vector 数组传参• execv• execvp• execve各个函数变体参数如上。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"第五章","slug":"第五章","permalink":"http://shenqidaxiansheng.github.io/tags/第五章/"},{"name":"模拟作业","slug":"模拟作业","permalink":"http://shenqidaxiansheng.github.io/tags/模拟作业/"}]},{"title":"操作系统导论第四章作业解题报告","slug":"操作系统导论第四章模拟作业解题报告","date":"2019-09-24T10:11:38.061Z","updated":"2019-09-24T16:45:32.113Z","comments":true,"path":"2019/09/24/操作系统导论第四章模拟作业解题报告/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/09/24/操作系统导论第四章模拟作业解题报告/","excerpt":"操作系统导论第四章：进程","text":"操作系统导论第四章：进程 定义进程就是运行中的程序 一台机器上如何同时运行多个程序？这里的关键问题是：如何提供有许多CPU的假象？ 我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？ 操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。 模拟作业操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载： 操作系统导论homework，加载时间可能会常一些，正常等待即可。 然后从该网站上下载本章需要的作业程序：process-run.py， 解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。 博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。 下面是本章作业1-5题的个人解答，只供参考： 11、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：-c检查： 和预期相符。 2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1. 所以完成这两个进程需要时间为 10； 检验： 预期相符。 3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1. 从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。 4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验： 与预期相符 5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验： 与预期相符。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"模拟作业","slug":"模拟作业","permalink":"http://shenqidaxiansheng.github.io/tags/模拟作业/"},{"name":"第四章","slug":"第四章","permalink":"http://shenqidaxiansheng.github.io/tags/第四章/"}]},{"title":"","slug":"新文档","date":"2019-08-15T13:42:39.129Z","updated":"2019-08-15T13:42:39.129Z","comments":true,"path":"2019/08/15/新文档/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/08/15/新文档/","excerpt":"","text":"java中的foreach语法形式：for(x:a)例如： int a[10], x; for(x:a)表示将a数组中的每个元素按下标索引的顺序赋值给x； 标签一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。","categories":[],"tags":[]},{"title":"test","slug":"index","date":"2019-08-01T19:34:51.000Z","updated":"2019-08-01T19:34:51.539Z","comments":true,"path":"2019/08/02/index/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/08/02/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo+github 搭建个人博客","slug":"hexo+github 搭建个人博客","date":"2019-07-29T07:58:11.000Z","updated":"2019-08-01T19:20:39.275Z","comments":true,"path":"2019/07/29/hexo+github 搭建个人博客/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/hexo+github 搭建个人博客/","excerpt":"博主的博客觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺","text":"博主的博客觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺ 准备工作由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号 注册github账号，你可以去这里注册：github登陆界面，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到 注册号github账号后，就可以去新建一个仓库，：如图点击new按钮，新建一个仓库，到了这个页面：仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。 下载git，可以去这里下载：git下载地址，点击download就可以下载了，下载完成安装就可以了 然后我们再安装nodejs具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单安装hexo前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here打开git bash ，不出意外你将得到这个界面：这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成输入以下代码安装hexo：npm install hexo -g安装完成后，输入hexo init完成初始化##关键一步：将hexo和GitHub上创建的仓库联系起来网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦首先，我们先输入以下命令： 1cd ~/. ssh 如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥输入以下命令 1ssh-keygen -t rsa -C \"邮件地址\" 邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\\id_rsa.pub，例如博主的这个文件就在这：用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：点击 new ssh key，是是啊撒大声地大大大是是是title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。有了ssh秘钥就可以把本地文件和github上的仓库联系起来继续在gitbash上执行如下命令： git config --global user.name &quot;username&quot;// 你的github用户名，非昵称 git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。 ##将本地博客上传到github上输入以下命令： hexo g hexo s然后在游览器上打开网址：http://localhost:4000就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。然后输入以下命令： hexo clean hexo g hexo dhexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）利用hexo大家博客完成 ##写博客博客搭好后，我们如何写博客并且上传到自己的博客页面？先按照这个路径点开这个文件夹：这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，执行命令： hexo new page &quot;my-first-blog&quot;就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（makedown下载地址）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了(╥╯^╰╥)","categories":[{"name":"搭建个人博客及美化","slug":"搭建个人博客及美化","permalink":"http://shenqidaxiansheng.github.io/categories/搭建个人博客及美化/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenqidaxiansheng.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://shenqidaxiansheng.github.io/tags/github/"},{"name":"个人博客","slug":"个人博客","permalink":"http://shenqidaxiansheng.github.io/tags/个人博客/"}]},{"title":"四六级词汇学习笔记","slug":"四六级词汇","date":"2019-07-29T07:58:11.000Z","updated":"2019-07-30T12:39:08.178Z","comments":true,"path":"2019/07/29/四六级词汇/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/四六级词汇/","excerpt":"四六级词汇学习笔记","text":"四六级词汇学习笔记 英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。 前缀示例：deriver from –源自于deviate from –偏离(deviate脱离）前缀：de -&gt; down(下降)derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于decrease(减少)decline(n.下降，vt 婉拒）(同义词 refus ，reject)前缀re 表示again再一次 或者 back返回retell 再讲一遍return 返回，回报词根fuse = flow 表示流动refuse 表示流回去（拒绝）ject-词根-扔reject 扔回去（强烈的拒绝） steam from 也表示源自于的意思steam 名词-根茎originate from 源自于 discount：n.折扣，v.认为..不重要前缀-dis-表示否定count计算，discount即表示打折扣 account：n.账目，赊账前缀-ac-强调作用a+辅音（aeiou五个字母为元音字母，其余为辅音字母）（元音字母可以替换但是意思不变，例如：begin-began-begunMan-Men）count-计数，数数counter ：计算器，计数器，柜台作形容词还可表示相反的作副词表示相反地作动词表示反对（OTC：over the counter）counterbalance:制衡（从相反的方向平衡） 后缀er（和or相同）-表示人或者物）cooker（厨具）tractor（拖拉机） 后缀示例：origin-n.起源-后缀ateoriginal-adj.原始的-后缀al fluctuate 起伏不定后缀-ate：1、名词，例如：graduate毕业生，candidate候选人2、动词，例如：graduate 毕业（动词）3、形容词，例如：private前缀：flu流动fluent：流利的后缀：ent=ant 表示形容词或者名词后缀account，servant，fluid名词 液体，形容词流动的反义词 solidinfluential前缀：in 表在里面也可表否定，这时一般做形容词前缀","categories":[{"name":"英语学习","slug":"英语学习","permalink":"http://shenqidaxiansheng.github.io/categories/英语学习/"}],"tags":[{"name":"英语学习,","slug":"英语学习","permalink":"http://shenqidaxiansheng.github.io/tags/英语学习/"},{"name":"四六级","slug":"四六级","permalink":"http://shenqidaxiansheng.github.io/tags/四六级/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-29T07:02:22.715Z","updated":"2019-07-29T08:23:27.991Z","comments":true,"path":"2019/07/29/hello-world/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}