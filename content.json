{"meta":{"title":"一只神奇的DXS","subtitle":"一名计算机学生的个人网站","description":"a computer student","author":"Jing Hua","url":"http://shenqidaxiansheng.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-29T12:23:49.000Z","updated":"2019-07-30T12:37:59.978Z","comments":true,"path":"categories/index.html","permalink":"http://shenqidaxiansheng.github.io/categories/index.html","excerpt":"","text":""},{"title":"test","date":"2019-08-01T19:34:51.000Z","updated":"2019-08-01T19:34:51.539Z","comments":true,"path":"test/index.html","permalink":"http://shenqidaxiansheng.github.io/test/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-29T12:22:43.000Z","updated":"2019-07-29T12:26:16.925Z","comments":true,"path":"tags/index.html","permalink":"http://shenqidaxiansheng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统导论第五章","slug":"操作系统导论第五章","date":"2019-09-24T17:18:23.188Z","updated":"2019-09-24T17:20:08.855Z","comments":true,"path":"2019/09/25/操作系统导论第五章/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/09/25/操作系统导论第五章/","excerpt":"操作系统导论第五章：进程API","text":"操作系统导论第五章：进程API UNIX的系统调用UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。 父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。 fork（）函数先贴一段简单的调用fork函数的代码 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123;printf(\"hello,world.\\n\");int x = 100;int rc = fork();if(rc&lt;0)&#123;fprintf(stderr,\"fork failed\\n\");exit(1);&#125;else if(rc==0)&#123;printf(\"hello,I am child\\n\");printf(\"x=%d\\n\",x+7);&#125;else&#123;printf(\"hello,I am parent\\n\");printf(\"x=%d\\n\",x+8);&#125;return 0;&#125;` 运行结果是： 可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。 exec函数调用12345678910111213141516171819202122232425262728293031#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/wait.h&gt;int main()&#123;int rc = fork();if(rc&lt;0)&#123;fprintf(stderr,\"fork failed\\n\");exit(1);&#125;else if(rc==0)&#123;printf(\"child\\n\");execl(\"/bin/ls\",\"ls\",\"-l\",NULL);execle(\"/bin/ls\",\"ls\",\"-l\",NULL,NULL);execlp(\"/bin/ls\",\"ls\",\"-l\",NULL);char *m[] = &#123;\"ls\",\"-l\",NULL&#125;;execve(\"/bin/ls\",m,NULL);execv(\"/bin/ls\",m);execvp(\"/bin/ls\",m);exit(1);&#125;else&#123;printf(\"parent\\n\");&#125;return 0;&#125; exec（）函数族有六个变体根据参数类型，大体可以分为两类：• 以 list 可变参数传参• execl• execlp• execle• 以 vector 数组传参• execv• execvp• execve各个函数变体参数如上。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"第五章","slug":"第五章","permalink":"http://shenqidaxiansheng.github.io/tags/第五章/"},{"name":"模拟作业","slug":"模拟作业","permalink":"http://shenqidaxiansheng.github.io/tags/模拟作业/"}]},{"title":"操作系统导论第四章作业解题报告","slug":"操作系统导论第四章模拟作业解题报告","date":"2019-09-24T10:11:38.061Z","updated":"2019-09-24T16:45:32.113Z","comments":true,"path":"2019/09/24/操作系统导论第四章模拟作业解题报告/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/09/24/操作系统导论第四章模拟作业解题报告/","excerpt":"操作系统导论第四章：进程","text":"操作系统导论第四章：进程 定义进程就是运行中的程序 一台机器上如何同时运行多个程序？这里的关键问题是：如何提供有许多CPU的假象？ 我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？ 操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。 模拟作业操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载： 操作系统导论homework，加载时间可能会常一些，正常等待即可。 然后从该网站上下载本章需要的作业程序：process-run.py， 解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。 博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。 下面是本章作业1-5题的个人解答，只供参考： 11、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：-c检查： 和预期相符。 2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1. 所以完成这两个进程需要时间为 10； 检验： 预期相符。 3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1. 从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。 4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验： 与预期相符 5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验： 与预期相符。","categories":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/categories/操作系统导论/"}],"tags":[{"name":"操作系统导论","slug":"操作系统导论","permalink":"http://shenqidaxiansheng.github.io/tags/操作系统导论/"},{"name":"模拟作业","slug":"模拟作业","permalink":"http://shenqidaxiansheng.github.io/tags/模拟作业/"},{"name":"第四章","slug":"第四章","permalink":"http://shenqidaxiansheng.github.io/tags/第四章/"}]},{"title":"","slug":"新文档","date":"2019-08-15T13:42:39.129Z","updated":"2019-08-15T13:42:39.129Z","comments":true,"path":"2019/08/15/新文档/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/08/15/新文档/","excerpt":"","text":"java中的foreach语法形式：for(x:a)例如： int a[10], x; for(x:a)表示将a数组中的每个元素按下标索引的顺序赋值给x； 标签一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。","categories":[],"tags":[]},{"title":"test","slug":"index","date":"2019-08-01T19:34:51.000Z","updated":"2019-08-01T19:34:51.539Z","comments":true,"path":"2019/08/02/index/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/08/02/index/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"hexo+github 搭建个人博客","slug":"hexo+github 搭建个人博客","date":"2019-07-29T07:58:11.000Z","updated":"2019-08-01T19:20:39.275Z","comments":true,"path":"2019/07/29/hexo+github 搭建个人博客/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/hexo+github 搭建个人博客/","excerpt":"博主的博客觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺","text":"博主的博客觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺ 准备工作由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号 注册github账号，你可以去这里注册：github登陆界面，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到 注册号github账号后，就可以去新建一个仓库，：如图点击new按钮，新建一个仓库，到了这个页面：仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。 下载git，可以去这里下载：git下载地址，点击download就可以下载了，下载完成安装就可以了 然后我们再安装nodejs具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单安装hexo前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here打开git bash ，不出意外你将得到这个界面：这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成输入以下代码安装hexo：npm install hexo -g安装完成后，输入hexo init完成初始化##关键一步：将hexo和GitHub上创建的仓库联系起来网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦首先，我们先输入以下命令： 1cd ~/. ssh 如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥输入以下命令 1ssh-keygen -t rsa -C \"邮件地址\" 邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\\id_rsa.pub，例如博主的这个文件就在这：用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：点击 new ssh key，是是啊撒大声地大大大是是是title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。有了ssh秘钥就可以把本地文件和github上的仓库联系起来继续在gitbash上执行如下命令： git config --global user.name &quot;username&quot;// 你的github用户名，非昵称 git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。 ##将本地博客上传到github上输入以下命令： hexo g hexo s然后在游览器上打开网址：http://localhost:4000就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。然后输入以下命令： hexo clean hexo g hexo dhexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）利用hexo大家博客完成 ##写博客博客搭好后，我们如何写博客并且上传到自己的博客页面？先按照这个路径点开这个文件夹：这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，执行命令： hexo new page &quot;my-first-blog&quot;就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（makedown下载地址）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了(╥╯^╰╥)","categories":[{"name":"搭建个人博客及美化","slug":"搭建个人博客及美化","permalink":"http://shenqidaxiansheng.github.io/categories/搭建个人博客及美化/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://shenqidaxiansheng.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://shenqidaxiansheng.github.io/tags/github/"},{"name":"个人博客","slug":"个人博客","permalink":"http://shenqidaxiansheng.github.io/tags/个人博客/"}]},{"title":"四六级词汇学习笔记","slug":"四六级词汇","date":"2019-07-29T07:58:11.000Z","updated":"2019-07-30T12:39:08.178Z","comments":true,"path":"2019/07/29/四六级词汇/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/四六级词汇/","excerpt":"四六级词汇学习笔记","text":"四六级词汇学习笔记 英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。 前缀示例：deriver from –源自于deviate from –偏离(deviate脱离）前缀：de -&gt; down(下降)derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于decrease(减少)decline(n.下降，vt 婉拒）(同义词 refus ，reject)前缀re 表示again再一次 或者 back返回retell 再讲一遍return 返回，回报词根fuse = flow 表示流动refuse 表示流回去（拒绝）ject-词根-扔reject 扔回去（强烈的拒绝） steam from 也表示源自于的意思steam 名词-根茎originate from 源自于 discount：n.折扣，v.认为..不重要前缀-dis-表示否定count计算，discount即表示打折扣 account：n.账目，赊账前缀-ac-强调作用a+辅音（aeiou五个字母为元音字母，其余为辅音字母）（元音字母可以替换但是意思不变，例如：begin-began-begunMan-Men）count-计数，数数counter ：计算器，计数器，柜台作形容词还可表示相反的作副词表示相反地作动词表示反对（OTC：over the counter）counterbalance:制衡（从相反的方向平衡） 后缀er（和or相同）-表示人或者物）cooker（厨具）tractor（拖拉机） 后缀示例：origin-n.起源-后缀ateoriginal-adj.原始的-后缀al fluctuate 起伏不定后缀-ate：1、名词，例如：graduate毕业生，candidate候选人2、动词，例如：graduate 毕业（动词）3、形容词，例如：private前缀：flu流动fluent：流利的后缀：ent=ant 表示形容词或者名词后缀account，servant，fluid名词 液体，形容词流动的反义词 solidinfluential前缀：in 表在里面也可表否定，这时一般做形容词前缀","categories":[{"name":"英语学习","slug":"英语学习","permalink":"http://shenqidaxiansheng.github.io/categories/英语学习/"}],"tags":[{"name":"英语学习,","slug":"英语学习","permalink":"http://shenqidaxiansheng.github.io/tags/英语学习/"},{"name":"四六级","slug":"四六级","permalink":"http://shenqidaxiansheng.github.io/tags/四六级/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-29T07:02:22.715Z","updated":"2019-07-29T08:23:27.991Z","comments":true,"path":"2019/07/29/hello-world/","link":"","permalink":"http://shenqidaxiansheng.github.io/2019/07/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}