<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统导论第五章</title>
      <link href="/2019/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2019/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统导论第五章：进程API"><a href="#操作系统导论第五章：进程API" class="headerlink" title="操作系统导论第五章：进程API"></a>操作系统导论第五章：进程API</h1><a id="more"></a><h2 id="UNIX的系统调用"><a href="#UNIX的系统调用" class="headerlink" title="UNIX的系统调用"></a>UNIX的系统调用</h2><p>UNIX采用一对系统调用：fork（）函数和exec（）函数，非常有趣的创建新进程。</p><p>父进程还可以通过第三个系统调用wait（），等待其创建的子进程完成并且回收，注意，子进程不能调用it（），否则wait（）函数会返回-1，而父进程调用则会返回子进程的PID。</p><h2 id="fork（）函数"><a href="#fork（）函数" class="headerlink" title="fork（）函数"></a>fork（）函数</h2><p><strong><em>先贴一段简单的调用fork函数的代码</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,world.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am child\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,I am parent\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x=%d\n"</span>,x+<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>运行结果是：</p><p><img alt data-src="https://img-blog.csdnimg.cn/20190925010803571.png"></p><p>可以看到是各改变各的值，并没有出现叠加的情况，父程序x变为108，子程序变为107a。<br>说明父子程序的变量x虽然拥有一样的初值，但是他们保存的地址是独立的，不同的，所以他们保存的值也是不同的，也就是他们完全拥有互相独立的数据和地址。<br>注意，fork函数的返回值父进程返回1，子进程返回0，除此之外，这两个进程完全相同。</p><h2 id="exec函数调用"><a href="#exec函数调用" class="headerlink" title="exec函数调用"></a>exec函数调用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span>(rc&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"fork failed\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rc==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line">execl(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line">execle(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">execlp(<span class="string">"/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *m[] = &#123;<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">execve(<span class="string">"/bin/ls"</span>,m,<span class="literal">NULL</span>);</span><br><span class="line">execv(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line">execvp(<span class="string">"/bin/ls"</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"parent\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exec（）函数族有六个变体<br>根据参数类型，大体可以分为两类：<br>•    以 list 可变参数传参<br>•    execl<br>•    execlp<br>•    execle<br>•    以 vector 数组传参<br>•    execv<br>•    execvp<br>•    execve<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190925011659188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>各个函数变体参数如上。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统导论 </tag>
            
            <tag> 第五章 </tag>
            
            <tag> 模拟作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统导论第四章作业解题报告</title>
      <link href="/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%A8%A1%E6%8B%9F%E4%BD%9C%E4%B8%9A%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统导论第四章：进程"><a href="#操作系统导论第四章：进程" class="headerlink" title="操作系统导论第四章：进程"></a>操作系统导论第四章：进程</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程就是运行中的程序</p><h2 id="一台机器上如何同时运行多个程序？"><a href="#一台机器上如何同时运行多个程序？" class="headerlink" title="一台机器上如何同时运行多个程序？"></a>一台机器上如何同时运行多个程序？</h2><p><strong><em>这里的关键问题是：如何提供有许多CPU的假象？</em></strong></p><p>我们知道，一个CPU只能运行一个进程，然而，实际上，一个正常的系统可能会有上百个程序正在运行，只有一个CPU的情况下，怎么同时运行这上百个程序？</p><p>操作系统通过虚拟化来提供这种假象。通过让一个进程只运行一个时间骗，然后切换到其它进程，因为CPU运行的速度非常快，我们肉眼通常是感受不到CPU的切换，所以这就造成了同时运行上百个程序的假象。</p><h1 id="模拟作业"><a href="#模拟作业" class="headerlink" title="模拟作业"></a>模拟作业</h1><p>操作系统导论的作者为这本书提供了一个homework网站，作业用到了程序以及相关资料可以从这里下载：</p><p><a href="http://http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html" target="_blank" rel="noopener">操作系统导论homework</a>，加载时间可能会常一些，正常等待即可。</p><p>然后从该网站上下载本章需要的作业程序：<em>process-run.py</em>，</p><p>解压后里面会有一个readme文件，把里面的内容通读一遍即可动手做作业。</p><p>博主是在Linux上运行的该程序，由于ubuntu16 自带python2.7版本的编译器，所以我不用再配置环境，解压程序直接运行即可，如果你不是用Linux，那么需要在python2.7的环境下运行该程序。</p><p>下面是本章作业1-5题的个人解答，只供参考：</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>1、CPU利用率为 100%，因为从运行结果来看，CPU一直在运行指令，没有出现等待空闲的情况：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180655603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>-c检查：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/2019092418071355.png"></p><p>和预期相符。</p><p>2、第一个进程运行时间为 4，第二个进程没有指定等待时间，默认为5，结束 时间 1.</p><p>所以完成这两个进程需要时间为 10；</p><p>检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180729945.png"></p><p>预期相符。</p><p>3、当交换进程运行时，发现在进程1请求Io时，CPU并未在等待状态，而是切换到进程2开始运行，等到进程1请求IO完成后再切换运行进程1.</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180754924.png"></p><p>从这里可以看出，交换顺序相当重要，合适的顺序能尽可能多的利用CPU，使得CPU空闲时间尽可能少，如上，进程1的IO等待时间运行进程2，提高了CPU利用率。</p><p>4、因为当 -S标志为 SWITCH_ON_END时，进程发出I/O系统不会切换到另一个进程，而是等待进程完成。所以，运行 -l 1:0,4:100 -c -S 时，系统不会像上面那样当进程1发出IO时CPU切换到进程2，而是等待进程1完成才切换到进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180820315.png"></p><p>与预期相符</p><p>5、因为当 -S 标志为 SWITCH_ON_IO时，系统将在进程发出IO请求时切换进程运行，所以运行-l 1:0,4:100 -c -S SWITCH_ON_IO，系统将不会出现等待情况而是直接运行进程2，检验：</p><p> <img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190924180834685.png"></p><p>与预期相符。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统导论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统导论 </tag>
            
            <tag> 模拟作业 </tag>
            
            <tag> 第四章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/15/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
      <url>/2019/08/15/%E6%96%B0%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java中的foreach语法"><a href="#java中的foreach语法" class="headerlink" title="java中的foreach语法"></a>java中的foreach语法</h1><p>形式：for(x:a)<br>例如：<br>   <code>int  a[10], x;</code><br>    <code>for(x:a)</code><br>表示将a数组中的每个元素按下标索引的顺序赋值给x；</p><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>一般来说，java中标签和continu、break连用，以达到跳出内外部迭代的目的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2019/08/02/index/"/>
      <url>/2019/08/02/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github 搭建个人博客</title>
      <link href="/2019/07/29/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/29/hexo+github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://shenqidaxiansheng.github.io/">博主的博客</a><br>觉得还不错的话，不用羡慕，跟着这篇博文，很快你也可以拥有一个自己的博客了☺</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>由于是利用GitHub和hexo搭建博客，所以需要下载相应的应用和注册github账号</p><ol><li>注册github账号，你可以去这里注册：<a href="https://github.com/" target="_blank" rel="noopener">github登陆界面</a>，具体这里不细说，很简单，跟注册其它的什么账号一样，不过需要绑定邮箱。需要注意取一个好听的username，后面会用到</li><li>注册号github账号后，就可以去新建一个仓库，：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802012834196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>如图点击new按钮，新建一个仓库，到了这个页面：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802013358361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>仓库名一定要是自己的 username.github.io，例如我的username是shenqidaxiansheng，那么我的仓库名就是 shenqidaxiansheng.github.io<br>新建完成后，你就可以在该仓库的设置界面随便选一个主题，然后在游览器输入你的仓库名，就可以访问到你的网站了，不过这一步无所谓，因为我们待会会用hexo搭建博客。</li><li>下载git，可以去这里下载：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git下载地址</a>，点击download就可以下载了，下载完成安装就可以了</li><li>然后我们再安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>具体的安装教程可以查阅网上，其实一直点next就可以了，比较简单<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2>前面的准备工作完成后，我们就可以安装hexo了，首先我们需要新建一个你想要放博客的文件夹，本人是创建了一个放在f盘下的hexo文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014643948.png"><br>创建好文件夹后，在这个文件夹下点击右键，然后点击git bash here<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802014955292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>打开git bash ，不出意外你将得到这个界面：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802031455315.jpg"><br>这个就是git的命令行界面了!，接下来的命令都是在这个文件夹下完成<br>输入以下代码安装hexo：<br><code>npm install hexo -g</code><br>安装完成后，输入<br><code>hexo init</code><br>完成初始化<br>##关键一步：将hexo和GitHub上创建的仓库联系起来<br>网上的其它教材对这一步都模糊其词，导致博主搭建博客的时候在这一步费了很多精力，现在把这个坑记下来，希望后来人不要在被坑在这里啦<br>首先，我们先输入以下命令：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.</span> ssh</span><br></pre></td></tr></table></figure><p>如果提示No such file or directory 说明你是第一次使用git，那么我们就需要配置ssh秘钥<br>输入以下命令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"邮件地址"</span></span><br></pre></td></tr></table></figure><p>邮箱地址是你注册时候填写的邮箱，然后连续三次回车，要输入 yse/no 你就输入yes，就会在用户目录下得到一个.ssh\id_rsa.pub，例如博主的这个文件就在这：<br><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802020710806.png"><br>用记事本打开这个文件，复制里面的内容，然后在GitHub的设置界面上打开这里：<br>点击 new ssh key，是是啊撒大声地大大大是是是<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802021007911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTc1NjEw,size_16,color_FFFFFF,t_70"><br>title 随便取，然后把刚刚复制的内容粘贴到key上，就创建成功了。<br>有了ssh秘钥就可以把本地文件和github上的仓库联系起来<br>继续在gitbash上执行如下命令：<br>    <code>git config --global user.name &quot;username&quot;// 你的github用户名，非昵称</code><br>    <code>git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的github注册邮箱</code><br>这一步就是把本地文件夹和github上的账号联系起来，以后你在本地文件夹的数据就可以上传到你的github仓库上面了。</p><p>##将本地博客上传到github上<br>输入以下命令：<br>    <code>hexo g</code><br>    <code>hexo s</code><br>然后在游览器上打开网址：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到自己的博客界面，此时系统自动帮你生成了一篇叫hello World 的文章。<br>然后输入以下命令：<br>    <code>hexo clean</code><br>    <code>hexo g</code><br>    <code>hexo d</code><br>hexo clean是清除, hexo g 是生成, hexo d是上传，建议每次上传博客前都要输入这三条命令。<br>输完这三条命令后，你就可以访问 username.github.io(username 是你的用户名，即在游览器上输入你的仓库名就可以访问到你自己的博客了）<br>利用hexo大家博客完成</p><p>##写博客<br>博客搭好后，我们如何写博客并且上传到自己的博客页面？<br>先按照这个路径点开这个文件夹：<img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20190802023807653.png"><br>这个_posts文件夹就是存放你写的博客的地方，可以看到这里有一篇helloworld，<br>执行命令：<br>    <code>hexo new page &quot;my-first-blog&quot;</code><br>就会生成一篇标题为 my-first-blog 的博文，然后你用文本编译器随便打开写点内容，你可以用makedown（<a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">makedown下载地址</a>）写，再执行刚刚说的指令,即hexo c，hexo g ， hexo d，你写好的博客就会出现在你的博客网站上了。<br>当然，刚刚新建好的博客使用的是系统默认的主题，名字、个人信息什么的也是系统自带的，博主将在下篇博客写如何美化博客，修改个人信息，太晚了，博主要睡觉了<br>(╥╯^╰╥)</p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客及美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四六级词汇学习笔记</title>
      <link href="/2019/07/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/"/>
      <url>/2019/07/29/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<h2 id="四六级词汇学习笔记"><a href="#四六级词汇学习笔记" class="headerlink" title="四六级词汇学习笔记"></a>四六级词汇学习笔记</h2><a id="more"></a><p>英语单词有前缀和后缀，前缀一般改变词义，后缀一般改变词性。</p><h2 id="前缀示例："><a href="#前缀示例：" class="headerlink" title="前缀示例："></a>前缀示例：</h2><p>deriver from –源自于<br>deviate from –偏离(deviate脱离）<br>前缀：de -&gt; down(下降)<br>derive from小河下降，小河从哪下降，即小河源自哪里，所以derive from表示源自于<br>decrease(减少)<br>decline(n.下降，vt 婉拒）<br>(同义词 refus ，reject)<br>前缀re 表示again再一次 或者 back返回<br>retell 再讲一遍<br>return 返回，回报<br>词根fuse = flow 表示流动<br>refuse 表示流回去（拒绝）<br>ject-词根-扔<br>reject 扔回去（强烈的拒绝）</p><p>steam from 也表示源自于的意思<br>steam 名词-根茎<br>originate from 源自于</p><p>discount：n.折扣，v.认为..不重要<br>前缀-dis-表示否定<br>count计算，discount即表示打折扣</p><p>account：n.账目，赊账<br>前缀-ac-强调作用<br>a+辅音<br>（aeiou五个字母为元音字母，其余为辅音字母）<br>（元音字母可以替换但是意思不变，例如：begin-began-begun<br>Man-Men）<br>count-计数，数数<br>counter ：计算器，计数器，柜台<br>作形容词还可表示相反的<br>作副词表示相反地<br>作动词表示反对<br>（OTC：over the counter）<br>counterbalance:制衡（从相反的方向平衡）</p><p>后缀er（和or相同）-表示人或者物）<br>cooker（厨具）<br>tractor（拖拉机）</p><h2 id="后缀示例："><a href="#后缀示例：" class="headerlink" title="后缀示例："></a>后缀示例：</h2><p>origin-n.起源-后缀ate<br>original-adj.原始的-后缀al</p><p>fluctuate 起伏不定<br>后缀-ate：<br>1、名词，例如：graduate毕业生，candidate候选人<br>2、动词，例如：graduate 毕业（动词）<br>3、形容词，例如：private<br>前缀：flu流动<br>fluent：流利的<br>后缀：ent=ant 表示形容词或者名词后缀<br>account，servant，<br>fluid<br>名词 液体，形容词流动的<br>反义词 solid<br>influential<br>前缀：in 表在里面<br>也可表否定，这时一般做形容词前缀</p>]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语学习, </tag>
            
            <tag> 四六级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/29/hello-world/"/>
      <url>/2019/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
